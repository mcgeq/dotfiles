* core-autoload.el
:PROPERTIES:
:HEADER-ARGS: :tangle core-autoload.el :lexical t
:END:

** Headers
#+BEGIN_SRC emacs-lisp
  ;;; core-autoload.el --- Auto-load and Auto-tangle for MCG Emacs -*- lexical-binding: t; -*-

  ;; Filename: core-autoload.el
  ;; Description: Auto-load and auto-tangle support
  ;; Author: mcge <mcgeq@outlook.com>
  ;; Copyright (C) 2024-2026, mcge, all rights reserved.
  ;; Create   Date: 2026-01-07
  ;; Version: 3.0
  ;; Keywords: autoload, tangle, automation
  ;; Compatibility: GNU Emacs 29.0+

  ;;; Commentary:
  ;;
  ;; Automation module for MCG Emacs configuration, providing:
  ;; - Auto-tangle .org files to .el on save
  ;; - Auto-scan extension directories to generate autoloads
  ;; - Simplified extension registration (auto-infer from directory structure)
  ;;

#+END_SRC

** Dependencies
#+BEGIN_SRC emacs-lisp
;;; Dependencies

(require 'core-bootstrap)

#+END_SRC

** Auto Tangle on Save
#+BEGIN_SRC emacs-lisp
;;; Auto Tangle on Save

(defvar mcg-auto-tangle-enabled t
  "Whether to enable auto-tangle on save.")

(defvar mcg-tangle-source-dir nil
  "Org source files directory.")

(defvar mcg-tangle-target-dir nil
  "Tangle target directory.")

(defun mcg--init-tangle-dirs ()
  "Initialize tangle directory variables."
  (setq mcg-tangle-source-dir mcg-config-org-dir)
  (setq mcg-tangle-target-dir mcg-config-dir))

(defun mcg--org-file-in-config-p (file)
  "Check if FILE is in the configuration directory."
  (and file
       mcg-tangle-source-dir
       (string-prefix-p (expand-file-name mcg-tangle-source-dir)
                        (expand-file-name file))))

(defun mcg--get-tangle-target (org-file)
  "Get the tangle target directory for ORG-FILE."
  (when (and org-file mcg-tangle-source-dir mcg-tangle-target-dir)
    (let* ((relative (file-relative-name org-file mcg-tangle-source-dir))
           (dir (file-name-directory relative)))
      (if dir
          (expand-file-name dir mcg-tangle-target-dir)
        mcg-tangle-target-dir))))

(defun mcg-auto-tangle ()
  "Auto-tangle current org file.

Only executes when file is in config-org directory."
  (when (and mcg-auto-tangle-enabled
             (eq major-mode 'org-mode)
             (mcg--org-file-in-config-p buffer-file-name))
    (let* ((org-file buffer-file-name)
           (target-dir (mcg--get-tangle-target org-file)))
      ;; Ensure target directory exists
      (unless (file-directory-p target-dir)
        (make-directory target-dir t))
      ;; Execute tangle
      (message "Auto-tangling: %s" (file-name-nondirectory org-file))
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle-file org-file nil "emacs-lisp"))
      ;; Move generated file to target directory
      (let* ((el-name (concat (file-name-base org-file) ".el"))
             (src-el (expand-file-name el-name (file-name-directory org-file)))
             (dst-el (expand-file-name el-name target-dir)))
        (when (and (file-exists-p src-el)
                   (not (string= src-el dst-el)))
          (rename-file src-el dst-el t)
          (message "Generated: %s" dst-el))))))

(defun mcg-setup-auto-tangle ()
  "Set up auto-tangle on save."
  (mcg--init-tangle-dirs)
  (add-hook 'after-save-hook #'mcg-auto-tangle))

(defun mcg/toggle-auto-tangle ()
  "Toggle auto-tangle feature."
  (interactive)
  (setq mcg-auto-tangle-enabled (not mcg-auto-tangle-enabled))
  (message "Auto-tangle %s" (if mcg-auto-tangle-enabled "enabled" "disabled")))

(defun mcg/tangle-current-file ()
  "Manually tangle current file."
  (interactive)
  (if (eq major-mode 'org-mode)
      (let ((mcg-auto-tangle-enabled t))
        (mcg-auto-tangle))
    (message "Not an org file")))

(defun mcg/tangle-all-config ()
  "Tangle all configuration files."
  (interactive)
  (mcg--init-tangle-dirs)
  (let ((org-files (directory-files-recursively
                    mcg-tangle-source-dir
                    "\\.org$")))
    (dolist (file org-files)
      (unless (string-match-p "README" file)
        (message "Tangling: %s" file)
        (let ((org-confirm-babel-evaluate nil))
          (org-babel-tangle-file file nil "emacs-lisp"))))
    (message "Tangled %d files" (length org-files))))

#+END_SRC

** Auto Extension Discovery
#+BEGIN_SRC emacs-lisp
;;; Auto Extension Discovery

(defvar mcg-extension-autoloads nil
  "Auto-generated extension autoload list.

Format is alist of ((MODE . PATH) ...).")

(defvar mcg-extension-cache nil
  "Extension path cache.

Format is alist of ((MODE-FILE . FULL-PATH) ...).
Used to avoid repeated directory scanning.")

(defvar mcg-extension-cache-file nil
  "Extension cache file path.")

(defun mcg--init-cache-file ()
  "Initialize cache file path."
  (setq mcg-extension-cache-file
        (expand-file-name "extension-cache.el" mcg-config-dir)))

(defun mcg-save-extension-cache ()
  "Save extension cache to file."
  (mcg--init-cache-file)
  (when (and mcg-extension-cache mcg-extension-cache-file)
    (with-temp-file mcg-extension-cache-file
      (insert ";; MCG Extension Cache - Auto-generated\n")
      (insert ";; Do not edit manually\n\n")
      (insert "(setq mcg-extension-cache\n  '")
      (prin1 mcg-extension-cache (current-buffer))
      (insert ")\n"))
    (mcg-log "Saved extension cache: %d entries" (length mcg-extension-cache))))

(defun mcg-load-extension-cache ()
  "Load extension cache from file."
  (mcg--init-cache-file)
  (when (and mcg-extension-cache-file
             (file-exists-p mcg-extension-cache-file))
    (condition-case err
        (progn
          (load mcg-extension-cache-file nil t)
          (mcg-log "Loaded extension cache: %d entries" (length mcg-extension-cache))
          t)
      (error
       (mcg-log "Failed to load cache: %s" (error-message-string err))
       nil))))

(defun mcg-cache-lookup (mode-file)
  "Look up extension path for MODE-FILE from cache."
  (cdr (assoc mode-file mcg-extension-cache)))

(defun mcg-cache-store (mode-file full-path)
  "Store MODE-FILE -> FULL-PATH mapping in cache."
  (unless (assoc mode-file mcg-extension-cache)
    (push (cons mode-file full-path) mcg-extension-cache)))

(defun mcg/rebuild-extension-cache ()
  "Rebuild extension cache."
  (interactive)
  (setq mcg-extension-cache nil)
  (mcg--scan-extension-dir mcg-extensions-dir)
  (mcg-save-extension-cache)
  (message "Extension cache rebuilt: %d entries" (length mcg-extension-cache)))

(defun mcg--scan-extension-dir (dir &optional prefix)
  "Scan extension directory DIR, return list of (path . features).

PREFIX is used to build relative paths.
Also updates mcg-extension-cache."
  (let ((result nil)
        (prefix (or prefix "")))
    (when (file-directory-p dir)
      (dolist (entry (directory-files dir t "^[^.]"))
        (when (file-directory-p entry)
          (let* ((name (file-name-nondirectory entry))
                 (path (if (string-empty-p prefix)
                           name
                         (concat prefix "/" name)))
                 (el-files (directory-files entry nil "\\.el$")))
            ;; If directory contains .el files, record it
            (if el-files
                (let ((features (mapcar (lambda (f)
                                          (let ((feat (intern (file-name-sans-extension f))))
                                            ;; Update cache
                                            (mcg-cache-store f entry)
                                            feat))
                                        el-files)))
                  (push (cons path features) result))
              ;; Otherwise recursively scan subdirectories
              (setq result (append result
                                   (mcg--scan-extension-dir entry path))))))))
    result))

(defun mcg-discover-extensions ()
  "Auto-discover all extensions and generate registry.

Scans mcg-extensions-dir directory, auto-infers extension paths and features.
Prioritizes cache, scans and saves if cache doesn't exist."
  (when (and mcg-extensions-dir (file-directory-p mcg-extensions-dir))
    ;; Try to load cache
    (unless mcg-extension-cache
      (mcg-load-extension-cache))
    ;; If cache is empty, scan and save
    (unless mcg-extension-cache
      (let ((discovered (mcg--scan-extension-dir mcg-extensions-dir)))
        (mcg-save-extension-cache)
        ;; Update mcg-extensions
        (dolist (ext discovered)
          (let ((path (car ext))
                (features (cdr ext)))
            (unless (assoc path mcg-extensions)
              (push (list path :provides features) mcg-extensions))))
        discovered))))

(defun mcg--infer-mode-from-path (path)
  "Infer mode name from extension path.

Example: \"lsp/web-mode\" -> web-mode"
  (let ((name (file-name-nondirectory path)))
    (intern (concat name (unless (string-suffix-p "-mode" name) "-mode")))))

(defun mcg-generate-autoloads ()
  "Auto-generate autoloads for all extensions.

Scans extension directory, sets up autoload for each extension containing -mode.el."
  (setq mcg-extension-autoloads nil)
  (when (and mcg-extensions-dir (file-directory-p mcg-extensions-dir))
    (dolist (entry (mcg--scan-extension-dir mcg-extensions-dir))
      (let* ((path (car entry))
             (features (cdr entry))
             (full-path (expand-file-name path mcg-extensions-dir)))
        ;; Find mode files
        (dolist (feat features)
          (let ((feat-name (symbol-name feat)))
            (when (string-suffix-p "-mode" feat-name)
              ;; Add to load-path
              (add-to-list 'load-path full-path)
              ;; Set up autoload
              (unless (fboundp feat)
                (autoload feat feat-name nil t))
              ;; Record
              (push (cons feat path) mcg-extension-autoloads))))))
    mcg-extension-autoloads))

(defun mcg-setup-extension-autoloads ()
  "Set up autoloads for all extensions.

This is an improved deferred loading scheme that doesn't require manually maintaining mcg-mode-extension-paths."
  (mcg-generate-autoloads)
  (message "Generated %d autoloads" (length mcg-extension-autoloads)))

#+END_SRC

** Simplified Extension Loading
#+BEGIN_SRC emacs-lisp
;;; Simplified Extension Loading

(defun mcg-load-ext (path &optional feature)
  "Simplified extension loading function.

Arguments:
- PATH: Extension relative path, e.g., \"lsp/web-mode\"
- FEATURE: Feature to require (optional, auto-inferred)

Auto-handles:
1. Adding path to load-path
2. Loading dependencies (if defined in registry)
3. Requiring feature"
  (let ((full-path (expand-file-name path mcg-extensions-dir)))
    (when (file-directory-p full-path)
      ;; Add to load-path
      (add-to-list 'load-path full-path)
      ;; Infer feature
      (let ((feat (or feature
                      (intern (file-name-nondirectory path)))))
        ;; Try to require
        (condition-case err
            (progn
              (require feat)
              t)
          (error
           (mcg-log "Failed to load %s: %s" path (error-message-string err))
           nil))))))

(defmacro mcg-use-ext (path &rest args)
  "Declarative extension usage macro (use-package style syntax).

Usage:
  (mcg-use-ext \"lsp/web-mode\"
    :feature web-mode
    :mode (\"\\\\.vue\\\\'\" . web-mode)
    :hook (web-mode-hook . my-web-setup)
    :defer t
    :init (setq web-mode-enable-auto-quoting nil)
    :config (setq web-mode-markup-indent-offset 2))

Arguments:
- PATH: Extension path
- :feature - Feature to load (optional)
- :mode - auto-mode-alist entry (optional)
- :hook - Hook setup (optional, supports multiple)
- :defer - Whether to defer loading (optional, default nil)
- :init - Code to execute before loading
- :config - Code to execute after loading
- :if / :when - Conditional loading
- :after - Load after specified feature"
  (declare (indent 1))
  (let* ((feature (plist-get args :feature))
         (mode (plist-get args :mode))
         (hook (plist-get args :hook))
         (defer (plist-get args :defer))
         (init (plist-get args :init))
         (config (plist-get args :config))
         (if-cond (or (plist-get args :if) (plist-get args :when)))
         (after (plist-get args :after))
         (feat-sym (or feature (intern (file-name-nondirectory path))))
         (body
          `(progn
             ;; Add to load-path
             (let ((full-path (expand-file-name ,path mcg-extensions-dir)))
               (when (file-directory-p full-path)
                 (add-to-list 'load-path full-path)))
             
             ;; :init - Execute before loading
             ,@(when init (if (listp (car init)) init (list init)))
             
             ;; Set up auto-mode-alist
             ,@(when mode
                 (if (and (consp mode) (stringp (car mode)))
                     `((add-to-list 'auto-mode-alist ',mode))
                   (mapcar (lambda (m) `(add-to-list 'auto-mode-alist ',m))
                           (if (consp (car mode)) mode (list mode)))))
             
             ;; Set up hook
             ,@(when hook
                 (if (and (consp hook) (symbolp (car hook)))
                     `((add-hook ',(car hook) #',(cdr hook)))
                   (mapcar (lambda (h) `(add-hook ',(car h) #',(cdr h)))
                           (if (consp (car hook)) hook (list hook)))))
             
             ;; Load or set up autoload
             ,(cond
               ;; :after - Load after specified feature
               (after
                `(with-eval-after-load ',after
                   (require ',feat-sym)
                   ,@(when config (if (listp (car config)) config (list config)))))
               ;; :defer - Deferred loading
               (defer
                `(progn
                   (autoload ',feat-sym ,(symbol-name feat-sym) nil t)
                   ,@(when config
                       `((with-eval-after-load ',feat-sym
                           ,@(if (listp (car config)) config (list config)))))))
               ;; Immediate loading
               (t
                `(progn
                   (require ',feat-sym)
                   ,@(when config (if (listp (car config)) config (list config)))))))))
    ;; Conditional wrapper
    (if if-cond
        `(when ,if-cond ,body)
      body)))

;; use-package style alias
(defalias 'use-ext 'mcg-use-ext)

#+END_SRC

** Extension Registry Auto-Update
#+BEGIN_SRC emacs-lisp
;;; Extension Registry Auto-Update

(defun mcg-refresh-extensions ()
  "Refresh extension registry.

Re-scans extension directory, updates mcg-extensions."
  (interactive)
  (let ((discovered (mcg-discover-extensions)))
    (message "Discovered %d extensions" (length discovered))
    discovered))

(defun mcg/show-discovered-extensions ()
  "Display auto-discovered extensions."
  (interactive)
  (let ((discovered (mcg-discover-extensions)))
    (with-current-buffer (get-buffer-create "*MCG Discovered Extensions*")
      (erase-buffer)
      (insert "Auto-discovered Extensions\n")
      (insert "==========================\n\n")
      (dolist (ext discovered)
        (insert (format "%-40s -> %s\n"
                        (car ext)
                        (mapconcat #'symbol-name (cdr ext) ", "))))
      (goto-char (point-min))
      (display-buffer (current-buffer)))))

#+END_SRC

** Provide
#+BEGIN_SRC emacs-lisp
(provide 'core-autoload)
;;; core-autoload.el ends here
#+END_SRC
