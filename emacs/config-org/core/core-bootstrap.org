* core-bootstrap.el
:PROPERTIES:
:HEADER-ARGS: :tangle (concat temporary-file-directory "core-bootstrap.el") :lexical t
:END:

** Headers
#+BEGIN_SRC emacs-lisp
  ;;; core-bootstrap.el --- Core Bootstrap for MCG Emacs -*- lexical-binding: t; -*-

  ;; Filename: core-bootstrap.el
  ;; Description: Core bootstrap module, defines path variables and performance optimization
  ;; Author: mcge <mcgeq@outlook.com>
  ;; Copyright (C) 2024-2026, mcge, all rights reserved.
  ;; Create   Date: 2026-01-07
  ;; Version: 3.0
  ;; Keywords: bootstrap, paths, performance
  ;; Compatibility: GNU Emacs 29.0+

  ;;; Commentary:
  ;;
  ;; Core bootstrap module for MCG Emacs configuration, responsible for:
  ;; - Defining all path variables
  ;; - Setting up load-path
  ;; - Performance optimization (GC, file-name-handler)
  ;; - Startup time tracking
  ;;
  ;; This module must be loaded before all other modules.
  ;;

#+END_SRC

** System Detection
#+BEGIN_SRC emacs-lisp
;;; System Detection

(defconst mcg-is-windows
  (memq system-type '(cygwin windows-nt ms-dos))
  "Running on a Windows system.")

(defconst mcg-is-linux
  (eq system-type 'gnu/linux)
  "Running on a GNU/Linux system.")

(defconst mcg-is-mac
  (eq system-type 'darwin)
  "Running on a macOS system.")

(defconst mcg-is-gui
  (memq window-system '(x w32 ns pc pgtk))
  "Running in GUI mode.")

(defconst mcg-emacs-29+
  (>= emacs-major-version 29)
  "Emacs is version 29 or above.")
#+END_SRC

** Path Variables
#+BEGIN_SRC emacs-lisp
;;; Path Variable Definitions

(defvar mcg-emacs-dir nil
  "Emacs configuration root directory (emacs/).")

(defvar mcg-core-dir nil
  "Core configuration directory (site-lisp/config/core/).")

(defvar mcg-modules-dir nil
  "Modules directory (site-lisp/config/modules/).")

(defvar mcg-extensions-dir nil
  "Extensions directory (site-lisp/extensions/).")

(defvar mcg-private-dir nil
  "Private configuration directory (site-lisp/config/private/).")

(defvar mcg-config-dir nil
  "Configuration root directory (site-lisp/config/).")

(defvar mcg-config-org-dir nil
  "Org source files directory (config-org/).")

(defvar mcg-site-lisp-dir nil
  "site-lisp directory.")

(defvar mcg-langservers-dir nil
  "LSP server configuration directory.")

(defvar mcg-multiservers-dir nil
  "LSP multi-server configuration directory.")

(defvar mcg-cache-dir nil
  "Cache directory for Emacs data files.")
#+END_SRC

** Path Initialization
#+BEGIN_SRC emacs-lisp
;;; Path Initialization

;; User-configurable base directory
;; Set this variable in early-init.el or .emacs (before require 'core-bootstrap)
;; Note: Using boundp check to ensure we don't override already set values
(unless (boundp 'mcg-base-dir)
  (defvar mcg-base-dir nil
    "Base directory for MCG configuration.

Users should set this variable before loading core-bootstrap, e.g.:
  (setq mcg-base-dir \"D:/config\")

Or set via environment variable MCG_EMACS_CONFIG_DIR.

If not set, ~ will be used as the default value."))

(defun mcg-init-paths (&optional base-dir)
  "Initialize all path variables.

Arguments:
- BASE-DIR: User-defined root directory (e.g., D:/config or ~)
            If nil, obtained in the following priority:
            1. mcg-base-dir variable
            2. Environment variable MCG_EMACS_CONFIG_DIR
            3. Default value ~

This function sets all mcg-* path variables and must be called before loading configuration.

Usage:
1. In .emacs: (setq mcg-base-dir \"D:/config\") then (require 'init)
2. Or set mcg-base-dir in early-init.el
3. Or set environment variable MCG_EMACS_CONFIG_DIR"
  (let* ((dir (or base-dir
                  (and (boundp 'mcg-base-dir) mcg-base-dir)
                  (getenv "MCG_EMACS_CONFIG_DIR")
                  "~"))
         (custom-dir (file-truename dir)))
    ;; Main directory
    (setq mcg-emacs-dir (expand-file-name "dotfiles/emacs" custom-dir))
    
    ;; site-lisp directory
    (setq mcg-site-lisp-dir (expand-file-name "site-lisp" mcg-emacs-dir))
    (setq mcg-extensions-dir (expand-file-name "extensions" mcg-site-lisp-dir))
    
    ;; Generated configuration directory (site-lisp/config/)
    (setq mcg-config-dir (expand-file-name "config" mcg-site-lisp-dir))
    (setq mcg-core-dir (expand-file-name "core" mcg-config-dir))
    (setq mcg-modules-dir (expand-file-name "modules" mcg-config-dir))
    (setq mcg-private-dir (expand-file-name "private" mcg-config-dir))
    
    ;; Org source files directory (config-org/)
    (setq mcg-config-org-dir (expand-file-name "config-org" mcg-emacs-dir))
    
    ;; LSP configuration directories
    (setq mcg-langservers-dir (expand-file-name "langservers" mcg-emacs-dir))
    (setq mcg-multiservers-dir (expand-file-name "multiservers" mcg-emacs-dir))
    
    ;; Cache directory (use user-emacs-directory for compatibility)
    (setq mcg-cache-dir (expand-file-name "cache" user-emacs-directory))
    (unless (file-directory-p mcg-cache-dir)
      (make-directory mcg-cache-dir t))
    
    ;; Return the used directory for debugging
    custom-dir))

;; Auto-initialize paths (using configured values or defaults)
(mcg-init-paths)
#+END_SRC

** Load Path Setup
#+BEGIN_SRC emacs-lisp
;;; Load Path Setup

(defun mcg-setup-load-path ()
  "Set up load-path, adding core configuration and extension directories.

This function adds the following directories to load-path:
1. site-lisp/config - Generated .el configuration files
2. site-lisp/config/core - Core modules
3. site-lisp/config/modules/* - Feature modules
4. site-lisp/extensions/* - All extension subdirectories"
  ;; Add configuration directory
  (let ((config-dir (expand-file-name "config" mcg-site-lisp-dir)))
    (when (file-directory-p config-dir)
      (add-to-list 'load-path config-dir)
      ;; Add core directory
      (add-to-list 'load-path (expand-file-name "core" config-dir))
      ;; Add modules subdirectories
      (let ((modules-dir (expand-file-name "modules" config-dir)))
        (when (file-directory-p modules-dir)
          (dolist (cat-dir (directory-files modules-dir t "^[^.]"))
            (when (file-directory-p cat-dir)
              (add-to-list 'load-path cat-dir)))))))
  
  ;; Recursively add extension directories
  (when (file-directory-p mcg-extensions-dir)
    (dolist (category-dir (directory-files mcg-extensions-dir t "^[^.]"))
      (when (file-directory-p category-dir)
        ;; Add category directory
        (add-to-list 'load-path category-dir)
        ;; Add subdirectories under category
        (dolist (ext-dir (directory-files category-dir t "^[^.]"))
          (when (file-directory-p ext-dir)
            (add-to-list 'load-path ext-dir)
            ;; Handle second-level subdirectories (e.g., lsp/clojure/)
            (dolist (sub-ext-dir (directory-files ext-dir t "^[^.]"))
              (when (file-directory-p sub-ext-dir)
                (add-to-list 'load-path sub-ext-dir)))))))))

;; Initialize load-path
(mcg-setup-load-path)
#+END_SRC

** Performance Optimization
#+BEGIN_SRC emacs-lisp
;;; Performance Optimization

;; Default GC settings (used after startup)
(defvar mcg-gc-cons-threshold-default (* 16 1024 1024)
  "Default GC threshold (16MB) for normal operation.")

(defvar mcg-gc-cons-percentage-default 0.1
  "Default GC percentage for normal operation.")

;; Restore settings after startup
;; Note: GC is disabled in early-init.el, restore here
(defun mcg--restore-startup-optimizations ()
  "Restore performance optimization settings after startup."
  (setq gc-cons-threshold mcg-gc-cons-threshold-default
        gc-cons-percentage mcg-gc-cons-percentage-default)
  ;; Restore file-name-handler-alist (saved in early-init.el)
  (when (boundp 'mcg--file-name-handler-alist-original)
    (setq file-name-handler-alist mcg--file-name-handler-alist-original)))

(add-hook 'emacs-startup-hook #'mcg--restore-startup-optimizations)

;; Minibuffer GC optimization
(defun mcg--minibuffer-gc-setup ()
  "Increase GC threshold in minibuffer."
  (setq gc-cons-threshold most-positive-fixnum))

(defun mcg--minibuffer-gc-restore ()
  "Restore GC threshold after minibuffer."
  (setq gc-cons-threshold mcg-gc-cons-threshold-default))

(add-hook 'minibuffer-setup-hook #'mcg--minibuffer-gc-setup)
(add-hook 'minibuffer-exit-hook #'mcg--minibuffer-gc-restore)

;; GC during idle time
(run-with-idle-timer 5 t #'garbage-collect)
#+END_SRC

** Startup Time Tracking
#+BEGIN_SRC emacs-lisp
;;; Startup Time Tracking

(defvar mcg-startup-time nil
  "Emacs startup time in seconds.")

(defvar mcg--startup-start-time (current-time)
  "Record Emacs startup start time.")

(defun mcg-display-startup-time ()
  "Display Emacs startup time."
  (let ((elapsed (float-time (time-subtract (current-time) mcg--startup-start-time))))
    (setq mcg-startup-time elapsed)
    (message "✨ Emacs loaded in %.2f seconds with %d garbage collections"
             elapsed gcs-done)))

(add-hook 'emacs-startup-hook #'mcg-display-startup-time)
#+END_SRC

** Native Compilation
#+BEGIN_SRC emacs-lisp
;;; Native Compilation Optimization

(when (and (fboundp 'native-comp-available-p)
           (native-comp-available-p))
  ;; Deferred compilation (native-comp-async-report-warnings-errors set in early-init.el)
  (setq native-comp-deferred-compilation t))

;; Byte compilation warnings
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC

** Logging
#+BEGIN_SRC emacs-lisp
;;; Logging System

(defvar mcg-debug-mode nil
  "Enable debug mode for verbose logging.")

(defvar mcg-profile-mode nil
  "Enable profiling mode to track load times.")

(defvar mcg-load-times nil
  "Record load times for modules/extensions.
Format is an alist of ((NAME . TIME-MS) ...).")

(defvar mcg-log-buffer nil
  "Buffer to store log messages.
Format is a list of (TIMESTAMP LEVEL MESSAGE).")

(defvar mcg-log-max-entries 500
  "Maximum number of log entries to keep.")

(defvar mcg-log-levels '(debug info warning error)
  "Available log levels in order of severity.")

(defun mcg--log-store (level message)
  "Store log MESSAGE with LEVEL to the log buffer.

Arguments:
- LEVEL: Log level symbol (debug, info, warning, error)
- MESSAGE: The log message string"
  (let ((entry (list (current-time) level message)))
    (push entry mcg-log-buffer)
    ;; Trim buffer if too large
    (when (> (length mcg-log-buffer) mcg-log-max-entries)
      (setq mcg-log-buffer (seq-take mcg-log-buffer mcg-log-max-entries)))))

(defmacro mcg-log (format-string &rest args)
  "Log message with FORMAT-STRING and ARGS.

Always stores the message to mcg-log-buffer.
Only outputs to *Messages* when `mcg-debug-mode' is non-nil."
  `(let ((msg (format ,format-string ,@args)))
     (mcg--log-store 'info msg)
     (when mcg-debug-mode
       (message (concat "[MCG] " msg)))))

(defun mcg-log-warning (format-string &rest args)
  "Log warning message with FORMAT-STRING and ARGS.

Always stores and displays warning messages."
  (let ((msg (apply #'format format-string args)))
    (mcg--log-store 'warning msg)
    (message "[MCG Warning] %s" msg)))

(defun mcg-log-error (format-string &rest args)
  "Log error message with FORMAT-STRING and ARGS.

Always stores and displays error messages."
  (let ((msg (apply #'format format-string args)))
    (mcg--log-store 'error msg)
    (message "[MCG Error] %s" msg)))

(defun mcg-log-debug (format-string &rest args)
  "Log debug message with FORMAT-STRING and ARGS.

Only stores and displays when `mcg-debug-mode' is non-nil."
  (when mcg-debug-mode
    (let ((msg (apply #'format format-string args)))
      (mcg--log-store 'debug msg)
      (message "[MCG Debug] %s" msg))))

(defmacro mcg-profile (name &rest body)
  "Execute BODY and record elapsed time to mcg-load-times.

Arguments:
- NAME: Identifier name
- BODY: Code to execute"
  (declare (indent 1))
  `(if mcg-profile-mode
       (let ((start-time (current-time)))
         (prog1 (progn ,@body)
           (let ((elapsed (* 1000 (float-time (time-subtract (current-time) start-time)))))
             (push (cons ,name elapsed) mcg-load-times)
             (mcg-log "⏱ %s: %.2fms" ,name elapsed))))
     (progn ,@body)))

(defun mcg/show-load-times ()
  "Display load times for all modules/extensions."
  (interactive)
  (if (null mcg-load-times)
      (message "No load times recorded. Set mcg-profile-mode to t before startup.")
    (with-current-buffer (get-buffer-create "*MCG Load Times*")
      (erase-buffer)
      (insert "MCG Load Time Statistics\n")
      (insert "========================\n\n")
      (let ((sorted (sort (copy-sequence mcg-load-times)
                          (lambda (a b) (> (cdr a) (cdr b)))))
            (total 0))
        (insert (format "%-50s %10s\n" "Name" "Time(ms)"))
        (insert (make-string 62 ?─))
        (insert "\n")
        (dolist (entry sorted)
          (insert (format "%-50s %10.2f\n" (car entry) (cdr entry)))
          (cl-incf total (cdr entry)))
        (insert (make-string 62 ?─))
        (insert "\n")
        (insert (format "%-50s %10.2f\n" "Total" total)))
      (goto-char (point-min))
      (display-buffer (current-buffer)))))

(defun mcg--format-log-entry (entry)
  "Format a log ENTRY for display.

ENTRY is (TIMESTAMP LEVEL MESSAGE)."
  (let* ((timestamp (car entry))
         (level (cadr entry))
         (message (caddr entry))
         (time-str (format-time-string "%H:%M:%S" timestamp))
         (level-str (upcase (symbol-name level)))
         (level-face (pcase level
                       ('error 'error)
                       ('warning 'warning)
                       ('debug 'font-lock-comment-face)
                       (_ 'default))))
    (format "[%s] %-7s %s" time-str level-str message)))

(defun mcg--filter-logs-by-level (logs min-level)
  "Filter LOGS to only include entries at or above MIN-LEVEL.

Arguments:
- LOGS: List of log entries
- MIN-LEVEL: Minimum log level symbol"
  (let ((min-idx (seq-position mcg-log-levels min-level)))
    (seq-filter
     (lambda (entry)
       (let ((entry-level (cadr entry)))
         (>= (seq-position mcg-log-levels entry-level) min-idx)))
     logs)))

(defun mcg--generate-logs-content (&optional level)
  "Generate log content string, optionally filtered by LEVEL."
  (let* ((logs (if level
                   (mcg--filter-logs-by-level mcg-log-buffer level)
                 mcg-log-buffer))
         (sorted-logs (reverse logs)))  ; Show oldest first
    (with-temp-buffer
      (insert "                    MCG Log Messages\n")
      (insert "    ═══════════════════════════════════════════════════\n\n")
      (if (null sorted-logs)
          (insert "    No log messages recorded.\n")
        (insert (format "    Showing %d entries" (length sorted-logs)))
        (when level
          (insert (format " (filtered: %s+)" (symbol-name level))))
        (insert "\n\n")
        (dolist (entry sorted-logs)
          (insert "    " (mcg--format-log-entry entry) "\n")))
      (insert "\n    ───────────────────────────────────────────────────\n")
      (insert "    Filter: d=debug i=info w=warning e=error a=all\n")
      (buffer-string))))

(defvar mcg--logs-popup-buffer "*MCG Logs*"
  "Buffer name for logs popup.")

(defvar mcg--logs-current-filter nil
  "Current log level filter.")

(defun mcg--logs-popup-scroll-down ()
  "Scroll logs popup content down."
  (when-let* ((buf (get-buffer mcg--logs-popup-buffer))
              (frame (buffer-local-value 'posframe--frame buf)))
    (with-selected-frame frame
      (ignore-errors (scroll-up 3)))))

(defun mcg--logs-popup-scroll-up ()
  "Scroll logs popup content up."
  (when-let* ((buf (get-buffer mcg--logs-popup-buffer))
              (frame (buffer-local-value 'posframe--frame buf)))
    (with-selected-frame frame
      (ignore-errors (scroll-down 3)))))

(defun mcg--logs-refresh-popup ()
  "Refresh the logs popup with current filter."
  (when-let ((buf (get-buffer mcg--logs-popup-buffer)))
    (with-current-buffer buf
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert (mcg--generate-logs-content mcg--logs-current-filter))))))

(defun mcg/show-logs (&optional level)
  "Display recent log messages in posframe popup.

Optional LEVEL argument filters logs by minimum level.
Keys: j/k scroll, d/i/w/e filter by level, a=all, q/ESC exit"
  (interactive)
  (require 'posframe)
  
  (setq mcg--logs-current-filter level)
  
  (let* ((buf (get-buffer-create mcg--logs-popup-buffer))
         (content (mcg--generate-logs-content level))
         (hint "j/k scroll | d/i/w/e/a filter | q/ESC exit")
         (padding (make-string (/ (- 60 (string-width hint)) 2) ?\s)))
    
    (with-current-buffer buf
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert content))
      (setq-local buffer-read-only t)
      (setq-local cursor-type nil)
      (setq-local header-line-format
                  (propertize (concat padding hint)
                              'face '(:foreground "#61AFEF" :weight bold)))
      (goto-char (point-min)))
    
    ;; Use posframe to display centered popup
    (posframe-show buf
                   :position (point)
                   :poshandler #'posframe-poshandler-frame-center
                   :internal-border-width 2
                   :internal-border-color "#61AFEF"
                   :background-color "#282C34"
                   :foreground-color "#ABB2BF"
                   :width 65
                   :height 35
                   :respect-header-line t
                   :accept-focus nil)
    
    ;; Use read-key loop to handle keys
    (unwind-protect
        (catch 'exit-popup
          (while t
            (let ((key (read-key)))
              (cond
               ;; Exit
               ((memq key '(?q 27))  ; q or ESC
                (throw 'exit-popup nil))
               ;; Scroll down
               ((memq key '(?j ?n 14))  ; j, n, C-n
                (mcg--logs-popup-scroll-down))
               ((equal key 'down)
                (mcg--logs-popup-scroll-down))
               ;; Scroll up
               ((memq key '(?k ?p 16))  ; k, p, C-p
                (mcg--logs-popup-scroll-up))
               ((equal key 'up)
                (mcg--logs-popup-scroll-up))
               ;; Filter by level
               ((eq key ?d)
                (setq mcg--logs-current-filter 'debug)
                (mcg--logs-refresh-popup))
               ((eq key ?i)
                (setq mcg--logs-current-filter 'info)
                (mcg--logs-refresh-popup))
               ((eq key ?w)
                (setq mcg--logs-current-filter 'warning)
                (mcg--logs-refresh-popup))
               ((eq key ?e)
                (setq mcg--logs-current-filter 'error)
                (mcg--logs-refresh-popup))
               ((eq key ?a)
                (setq mcg--logs-current-filter nil)
                (mcg--logs-refresh-popup))
               ;; Ignore other keys
               (t nil)))))
      ;; Cleanup
      (posframe-hide mcg--logs-popup-buffer))))

(defun mcg/clear-logs ()
  "Clear all log messages."
  (interactive)
  (setq mcg-log-buffer nil)
  (message "MCG logs cleared."))

(defun mcg/toggle-debug-mode ()
  "Toggle debug mode."
  (interactive)
  (setq mcg-debug-mode (not mcg-debug-mode))
  (message "MCG debug mode %s" (if mcg-debug-mode "enabled" "disabled")))

(defun mcg/toggle-profile-mode ()
  "Toggle profiling mode."
  (interactive)
  (setq mcg-profile-mode (not mcg-profile-mode))
  (message "MCG profile mode %s" (if mcg-profile-mode "enabled" "disabled")))

#+END_SRC

** Provide
#+BEGIN_SRC emacs-lisp
(provide 'core-bootstrap)
;;; core-bootstrap.el ends here
#+END_SRC
