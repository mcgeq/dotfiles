* init-loadpath.el (Version 2.0 - 重构后)
:PROPERTIES:
:HEADER-ARGS: :tangle (concat temporary-file-directory "init-loadpath.el") :lexical t
:END:

** Headers
#+BEGIN_SRC emacs-lisp
  ;;; init-loadpath.el -- Load-path Management V2 -*- lexical-binding: t; -*-

  ;; Filename: init-loadpath.el
  ;; Description: 统一管理所有Git Submodules的load-path（重构版本）
  ;; Author: mcge <mcgeq@outlook.com>
  ;; Copyright (C) 2024-2025, mcge, all rights reserved.
  ;; Create   Date: 2025-01-04 15:00:00
  ;; Version: 2.0
  ;; Modified   By: mcge <mcgeq@outlook.com>
  ;; Last Modified: <2025-12-01 Sun 18:30>
  ;; Keywords: load-path, submodules, extensions
  ;; Compatibility: GNU Emacs 29.0+

  ;;; Commentary:
  ;;
  ;; 重构后的 load-path 管理系统，采用更清晰的目录结构：
  ;;
  ;; site-lisp/extensions/
  ;;   ├── core/         - 核心库（dash, s.el, f.el等）
  ;;   ├── completion/   - 补全系统（vertico, marginalia等）
  ;;   ├── editor/       - 编辑器增强
  ;;   ├── git/          - 版本控制
  ;;   ├── lsp/          - LSP和语言支持
  ;;   ├── org/          - Org Mode生态
  ;;   ├── ui/           - 用户界面和主题
  ;;   ├── search/       - 搜索工具
  ;;   ├── snippets/     - 代码片段
  ;;   ├── input/        - 输入法
  ;;   ├── docs/         - 文档工具
  ;;   └── utils/        - 实用工具
  ;;

#+END_SRC

** Category Definitions
#+BEGIN_SRC emacs-lisp
;;; 扩展类别定义

(defvar mcg-extension-categories
  '(core completion editor git lsp org ui search snippets input docs utils)
  "所有扩展类别列表，按加载优先级排序")

(defvar mcg-category-descriptions
  '((core . "核心库和基础设施")
    (completion . "补全和选择框架")
    (editor . "编辑器功能增强")
    (git . "版本控制工具")
    (lsp . "LSP和语言支持")
    (org . "Org Mode生态系统")
    (ui . "用户界面和主题")
    (search . "搜索和导航工具")
    (snippets . "代码片段系统")
    (input . "输入法和输入增强")
    (docs . "文档编辑和预览")
    (utils . "通用实用工具"))
  "扩展类别描述")
#+END_SRC

** Extension Registry V2 (Enhanced Structure)
#+BEGIN_SRC emacs-lisp
;;; 扩展注册表 V2（增强结构）
;;; 包含依赖管理、版本信息和元数据

(defvar mcg-extension-registry-v2
  `(
    ;; === Core === 核心库
    ("core/dash"
     :priority 0 :required t :auto-load nil
     :depends nil
     :provides (dash dash-functional)
     :version "2.19.1"
     :upstream "https://github.com/magnars/dash.el"
     :description "Modern list library for Emacs")
    ("core/s.el"
     :priority 0 :required t :auto-load nil
     :depends nil
     :provides (s)
     :version "1.13.1"
     :upstream "https://github.com/magnars/s.el"
     :description "String manipulation library")
    ("core/f.el"
     :priority 0 :required t :auto-load nil
     :depends ("core/dash" "core/s.el")
     :provides (f)
     :version "0.20.0"
     :upstream "https://github.com/rejeep/f.el"
     :description "File and directory manipulation library")
    ("core/ht"
     :priority 0 :required nil :auto-load nil
     :depends ("core/dash")
     :provides (ht)
     :version nil
     :upstream "https://github.com/Wilfred/ht.el"
     :description "Hash table library")
    ("core/popup-el"
     :priority 0 :required nil :auto-load nil
     :depends nil
     :provides (popup)
     :version nil
     :upstream "https://github.com/auto-complete/popup-el"
     :description "Visual popup interface library")
    ("core/lazy-load"
     :priority 0 :required nil :auto-load nil
     :depends nil
     :provides (lazy-load)
     :version nil
     :upstream nil
     :description "Lazy loading utilities")
    ("core/compat"
     :priority 0 :required t :auto-load nil
     :depends nil
     :provides (compat)
     :version "30.0.0.0"
     :upstream "https://github.com/emacs-compat/compat"
     :description "Emacs compatibility library")
    ("core/cond-let"
     :priority 0 :required t :auto-load nil
     :depends nil
     :provides (cond-let)
     :version nil
     :upstream nil
     :description "Conditional let bindings")

    ;; === Completion === 补全系统
    ("completion/vertico"
     :priority 10 :required nil :auto-load nil
     :depends ("core/compat")
     :provides (vertico vertico-directory)
     :version nil
     :upstream "https://github.com/minad/vertico"
     :description "Vertical interactive completion")
    ("completion/marginalia"
     :priority 10 :required nil :auto-load nil
     :depends ("core/compat")
     :provides (marginalia)
     :version nil
     :upstream "https://github.com/minad/marginalia"
     :description "Rich annotations in minibuffer")
    ("completion/orderless"
     :priority 10 :required nil :auto-load nil
     :depends nil
     :provides (orderless)
     :version nil
     :upstream "https://github.com/oantolin/orderless"
     :description "Orderless completion style")
    ("completion/embark"
     :priority 20 :required nil :auto-load nil
     :depends ("core/compat")
     :provides (embark embark-consult)
     :version nil
     :upstream "https://github.com/oantolin/embark"
     :description "Context-sensitive actions")
    ("completion/consult"
     :priority 20 :required nil :auto-load nil
     :depends ("core/compat")
     :provides (consult)
     :version nil
     :upstream "https://github.com/minad/consult"
     :description "Consulting completing-read")
    ("completion/pinyinlib"
     :priority 20 :required nil :auto-load nil
     :depends nil
     :provides (pinyinlib)
     :version nil
     :upstream "https://github.com/cute-jumper/pinyinlib.el"
     :description "Pinyin input support")

    ;; === Editor === 编辑器增强
    ("editor/beacon"
     :priority 30 :required nil :auto-load nil
     :depends nil
     :provides (beacon)
     :version nil
     :upstream "https://github.com/Malabarba/beacon"
     :description "Highlight cursor position after scroll")
    ("editor/symbol-overlay"
     :priority 30 :required nil :auto-load nil
     :depends nil
     :provides (symbol-overlay)
     :version nil
     :upstream "https://github.com/wolray/symbol-overlay"
     :description "Highlight symbols with overlays")
    ("editor/vundo"
     :priority 30 :required nil :auto-load nil
     :depends nil
     :provides (vundo)
     :version nil
     :upstream "https://github.com/casouri/vundo"
     :description "Visual undo tree")
    ("editor/fingertip"
     :priority 30 :required nil :auto-load nil
     :depends nil
     :provides (fingertip)
     :version nil
     :upstream "https://github.com/manateelazycat/fingertip"
     :description "Structural editing")
    ("editor/wraplish"
     :priority 30 :required nil :auto-load nil
     :depends nil
     :provides (wraplish)
     :version nil
     :upstream "https://github.com/manateelazycat/wraplish"
     :description "Auto wrap English words")
    ("editor/markmacro"
     :priority 30 :required nil :auto-load nil
     :depends nil
     :provides (markmacro)
     :version nil
     :upstream "https://github.com/manateelazycat/markmacro"
     :description "Mark and apply macros")
    ("editor/ws-butler"
     :priority 30 :required nil :auto-load nil
     :depends nil
     :provides (ws-butler)
     :version nil
     :upstream "https://github.com/lewang/ws-butler"
     :description "Trim trailing whitespace")
    ("editor/dirvish"
     :priority 30 :required nil :auto-load nil
     :depends ("core/compat")
     :provides (dirvish)
     :version nil
     :upstream "https://github.com/alexluigit/dirvish"
     :description "Modern file manager")

    ;; === Git === 版本控制
    ("git/magit"
     :priority 70 :required nil :auto-load nil
     :depends ("core/compat" "core/dash" "git/with-editor")
     :provides (magit)
     :version nil
     :upstream "https://github.com/magit/magit"
     :description "Git porcelain inside Emacs")
    ("git/with-editor"
     :priority 70 :required nil :auto-load nil
     :depends ("core/compat")
     :provides (with-editor)
     :version nil
     :upstream "https://github.com/magit/with-editor"
     :description "Use Emacs as external editor")
    ("git/jujutsu"
     :priority 70 :required nil :auto-load nil
     :depends nil
     :provides (jujutsu)
     :version nil
     :upstream nil
     :description "Jujutsu VCS support")
    ("git/llama"
     :priority 70 :required nil :auto-load nil
     :depends nil
     :provides (llama)
     :version nil
     :upstream "https://github.com/tarsius/llama"
     :description "Compact lambda syntax")

    ;; === LSP === LSP和语言支持
    ("lsp/lsp-bridge"
     :priority 100 :required nil :auto-load nil
     :depends ("core/dash")
     :provides (lsp-bridge)
     :version nil
     :upstream "https://github.com/manateelazycat/lsp-bridge"
     :description "Fastest LSP client")
    ("lsp/acm-terminal"
     :priority 100 :required nil :auto-load nil
     :depends ("lsp/lsp-bridge")
     :provides (acm-terminal)
     :version nil
     :upstream "https://github.com/manateelazycat/acm-terminal"
     :description "ACM terminal backend")
    ("lsp/emacs-popon"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (popon)
     :version nil
     :upstream "https://codeberg.org/akib/emacs-popon"
     :description "Pop-on overlay library")
    ("lsp/treesit-auto"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (treesit-auto)
     :version nil
     :upstream "https://github.com/renzmann/treesit-auto"
     :description "Auto install tree-sitter grammars")
    ("lsp/rust-mode"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (rust-mode)
     :version nil
     :upstream "https://github.com/rust-lang/rust-mode"
     :description "Rust language support")
    ("lsp/lua-mode"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (lua-mode)
     :version nil
     :upstream "https://github.com/immerrr/lua-mode"
     :description "Lua language support")
    ("lsp/web-mode"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (web-mode)
     :version nil
     :upstream "https://github.com/fxbois/web-mode"
     :description "Web template editing")
    ("lsp/js2-mode"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (js2-mode)
     :version nil
     :upstream "https://github.com/mooz/js2-mode"
     :description "JavaScript IDE")
    ("lsp/modern-cpp-font-lock"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (modern-cpp-font-lock)
     :version nil
     :upstream "https://github.com/ludwigpacifici/modern-cpp-font-lock"
     :description "Modern C++ font lock")
    ("lsp/multiple-cursors"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (multiple-cursors)
     :version nil
     :upstream "https://github.com/magnars/multiple-cursors.el"
     :description "Multiple cursors editing")
    ("lsp/cloel"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (cloel)
     :version nil
     :upstream nil
     :description "Clojure Emacs Lisp bridge")
    ;; Clojure 子目录
    ("lsp/clojure/clojure-mode"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (clojure-mode)
     :version nil
     :upstream "https://github.com/clojure-emacs/clojure-mode"
     :description "Clojure major mode")
    ("lsp/clojure/clojure-ts-mode"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (clojure-ts-mode)
     :version nil
     :upstream "https://github.com/clojure-emacs/clojure-ts-mode"
     :description "Clojure tree-sitter mode")
    ("lsp/clojure/cider"
     :priority 100 :required nil :auto-load nil
     :depends ("lsp/clojure/clojure-mode" "lsp/clojure/parseedn" "lsp/clojure/sesman")
     :provides (cider)
     :version nil
     :upstream "https://github.com/clojure-emacs/cider"
     :description "Clojure IDE")
    ("lsp/clojure/clj-refactor"
     :priority 100 :required nil :auto-load nil
     :depends ("lsp/clojure/cider")
     :provides (clj-refactor)
     :version nil
     :upstream "https://github.com/clojure-emacs/clj-refactor.el"
     :description "Clojure refactoring")
    ("lsp/clojure/paredit"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (paredit)
     :version nil
     :upstream "https://paredit.org"
     :description "Structural editing for Lisp")
    ("lsp/clojure/parseclj"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (parseclj)
     :version nil
     :upstream "https://github.com/clojure-emacs/parseclj"
     :description "Clojure parser")
    ("lsp/clojure/parseedn"
     :priority 100 :required nil :auto-load nil
     :depends ("lsp/clojure/parseclj")
     :provides (parseedn)
     :version nil
     :upstream "https://github.com/clojure-emacs/parseedn"
     :description "EDN parser")
    ("lsp/clojure/queue"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (queue)
     :version nil
     :upstream nil
     :description "Queue data structure")
    ("lsp/clojure/spinner"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (spinner)
     :version nil
     :upstream "https://github.com/Malabarba/spinner.el"
     :description "Spinner progress indicator")
    ("lsp/clojure/sesman"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (sesman)
     :version nil
     :upstream "https://github.com/vspinu/sesman"
     :description "Session manager")
    ("lsp/clojure/jump"
     :priority 100 :required nil :auto-load nil
     :depends nil
     :provides (jump)
     :version nil
     :upstream nil
     :description "Jump to definition")

    ;; === Org === Org Mode生态
    ("org/org-modern"
     :priority 200 :required nil :auto-load nil
     :depends ("core/compat")
     :provides (org-modern)
     :version nil
     :upstream "https://github.com/minad/org-modern"
     :description "Modern Org mode styling")
    ("org/org-appear"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (org-appear)
     :version nil
     :upstream "https://github.com/awth13/org-appear"
     :description "Auto-toggle Org elements")
    ("org/org-superstar-mode"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (org-superstar)
     :version nil
     :upstream "https://github.com/integral-dw/org-superstar-mode"
     :description "Prettify Org bullets")
    ("org/org-supertag"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (org-supertag)
     :version nil
     :upstream nil
     :description "Enhanced Org tags")
    ("org/org-numbering"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (org-numbering)
     :version nil
     :upstream nil
     :description "Org heading numbering")
    ("org/org-download"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (org-download)
     :version nil
     :upstream "https://github.com/abo-abo/org-download"
     :description "Drag and drop images to Org")
    ("org/ox-hugo"
     :priority 200 :required nil :auto-load nil
     :depends ("org/tomelr")
     :provides (ox-hugo)
     :version nil
     :upstream "https://github.com/kaushalmodi/ox-hugo"
     :description "Export Org to Hugo")
    ("org/ox-gfm"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (ox-gfm)
     :version nil
     :upstream "https://github.com/larstvei/ox-gfm"
     :description "Export Org to GitHub Markdown")
    ("org/tomelr"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (tomelr)
     :version nil
     :upstream "https://github.com/kaushalmodi/tomelr"
     :description "TOML encoder")
    ("org/easy-hugo"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (easy-hugo)
     :version nil
     :upstream "https://github.com/masasam/emacs-easy-hugo"
     :description "Hugo blog management")
    ("org/emacs-request"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (request)
     :version nil
     :upstream "https://github.com/tkf/emacs-request"
     :description "HTTP request library")
    ("org/emacs-async"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (async)
     :version nil
     :upstream "https://github.com/jwiegley/emacs-async"
     :description "Asynchronous processing")
    ("org/cal-china-x"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (cal-china-x)
     :version nil
     :upstream "https://github.com/xwl/cal-china-x"
     :description "Chinese calendar")
    ("org/visual-fill-column"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (visual-fill-column)
     :version nil
     :upstream "https://codeberg.org/joostkremers/visual-fill-column"
     :description "Soft wrap at fill-column")
    ("org/mixed-pitch"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (mixed-pitch)
     :version nil
     :upstream "https://gitlab.com/jabranham/mixed-pitch"
     :description "Mixed pitch fonts")

    ;; === UI === 用户界面和主题
    ("ui/doom-modeline"
     :priority 1 :required nil :auto-load nil
     :depends ("core/compat" "ui/shrink-path" "ui/themes/nerd-icons")
     :provides (doom-modeline)
     :version nil
     :upstream "https://github.com/seagle0128/doom-modeline"
     :description "Fancy modeline")
    ("ui/shrink-path"
     :priority 1 :required nil :auto-load nil
     :depends ("core/dash" "core/s.el" "core/f.el")
     :provides (shrink-path)
     :version nil
     :upstream "https://gitlab.com/bennya/shrink-path.el"
     :description "Shrink file paths")
    ("ui/solaire-mode"
     :priority 1 :required nil :auto-load nil
     :depends nil
     :provides (solaire-mode)
     :version nil
     :upstream "https://github.com/hlissner/emacs-solaire-mode"
     :description "Distinguish file buffers")
    ("ui/themes/modus-themes"
     :priority 1 :required nil :auto-load nil
     :depends nil
     :provides (modus-themes)
     :version nil
     :upstream "https://github.com/protesilaos/modus-themes"
     :description "Accessible themes")
    ("ui/themes/ef-themes"
     :priority 1 :required nil :auto-load nil
     :depends nil
     :provides (ef-themes)
     :version nil
     :upstream "https://github.com/protesilaos/ef-themes"
     :description "Colorful themes")
    ("ui/themes/nerd-icons"
     :priority 1 :required nil :auto-load nil
     :depends nil
     :provides (nerd-icons)
     :version nil
     :upstream "https://github.com/rainstormstudio/nerd-icons.el"
     :description "Nerd font icons")
    ("ui/themes/nerd-icons-completion"
     :priority 2 :required nil :auto-load nil
     :depends ("ui/themes/nerd-icons")
     :provides (nerd-icons-completion)
     :version nil
     :upstream "https://github.com/rainstormstudio/nerd-icons-completion"
     :description "Icons for completion")

    ;; === Search === 搜索工具
    ("search/blink-search"
     :priority 50 :required nil :auto-load nil
     :depends nil
     :provides (blink-search)
     :version nil
     :upstream "https://github.com/manateelazycat/blink-search"
     :description "Fast fuzzy search")
    ("search/color-rg"
     :priority 50 :required nil :auto-load nil
     :depends nil
     :provides (color-rg)
     :version nil
     :upstream "https://github.com/manateelazycat/color-rg"
     :description "Colorful ripgrep")
    ("search/consult-todo"
     :priority 50 :required nil :auto-load nil
     :depends ("completion/consult" "search/hl-todo")
     :provides (consult-todo)
     :version nil
     :upstream "https://github.com/liuyinz/consult-todo"
     :description "Search TODOs with consult")
    ("search/hl-todo"
     :priority 50 :required nil :auto-load nil
     :depends ("core/compat")
     :provides (hl-todo)
     :version nil
     :upstream "https://github.com/tarsius/hl-todo"
     :description "Highlight TODO keywords")

    ;; === Snippets === 代码片段
    ("snippets/yasnippet"
     :priority 31 :required nil :auto-load nil
     :depends nil
     :provides (yasnippet)
     :version nil
     :upstream "https://github.com/joaotavora/yasnippet"
     :description "Template system")
    ("snippets/yasnippet-snippet"
     :priority 31 :required nil :auto-load nil
     :depends ("snippets/yasnippet")
     :provides nil
     :version nil
     :upstream "https://github.com/AndreaCrotti/yasnippet-snippets"
     :description "Snippet collection")

    ;; === Input === 输入法
    ("input/emacs-rime"
     :priority 40 :required nil :auto-load nil
     :depends ("input/posframe")
     :provides (rime)
     :version nil
     :upstream "https://github.com/DogLooksGood/emacs-rime"
     :description "Rime input method")
    ("input/posframe"
     :priority 40 :required nil :auto-load nil
     :depends nil
     :provides (posframe)
     :version nil
     :upstream "https://github.com/tumashu/posframe"
     :description "Pop up frame at point")

    ;; === Docs === 文档工具
    ("docs/markdown-mode"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (markdown-mode)
     :version nil
     :upstream "https://github.com/jrblevin/markdown-mode"
     :description "Markdown major mode")
    ("docs/markdown-ts-mode"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (markdown-ts-mode)
     :version nil
     :upstream nil
     :description "Markdown tree-sitter mode")
    ("docs/grip-mode"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (grip-mode)
     :version nil
     :upstream "https://github.com/seagle0128/grip-mode"
     :description "GitHub README preview")
    ("docs/flymake-vale"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (flymake-vale)
     :version nil
     :upstream "https://github.com/tpeacock19/flymake-vale"
     :description "Vale prose linter")
    ("docs/emacs-htmlize"
     :priority 200 :required nil :auto-load nil
     :depends nil
     :provides (htmlize)
     :version nil
     :upstream "https://github.com/hniksic/emacs-htmlize"
     :description "Convert buffer to HTML")

    ;; === Utils === 实用工具
    ("utils/auto-save"
     :priority 40 :required nil :auto-load nil
     :depends nil
     :provides (auto-save)
     :version nil
     :upstream "https://github.com/manateelazycat/auto-save"
     :description "Auto save buffers")
    ("utils/sort-tab"
     :priority 40 :required nil :auto-load nil
     :depends nil
     :provides (sort-tab)
     :version nil
     :upstream "https://github.com/manateelazycat/sort-tab"
     :description "Sort tabs by usage")
    ("utils/helpful"
     :priority 50 :required nil :auto-load nil
     :depends ("core/dash" "core/s.el" "utils/elisp-refs")
     :provides (helpful)
     :version nil
     :upstream "https://github.com/Wilfred/helpful"
     :description "Better help buffers")
    ("utils/elisp-refs"
     :priority 50 :required nil :auto-load nil
     :depends ("core/dash" "core/s.el")
     :provides (elisp-refs)
     :version nil
     :upstream "https://github.com/Wilfred/elisp-refs"
     :description "Find Elisp references")
    ("utils/hydra"
     :priority 60 :required nil :auto-load nil
     :depends nil
     :provides (hydra)
     :version nil
     :upstream "https://github.com/abo-abo/hydra"
     :description "Sticky key bindings")
    ("utils/instant-rename-tag"
     :priority 60 :required nil :auto-load nil
     :depends nil
     :provides (instant-rename-tag)
     :version nil
     :upstream "https://github.com/manateelazycat/instant-rename-tag"
     :description "Rename HTML tags instantly")
    ("utils/highlight-matching-tag"
     :priority 60 :required nil :auto-load nil
     :depends nil
     :provides (highlight-matching-tag)
     :version nil
     :upstream "https://github.com/AckslD/highlight-matching-tag"
     :description "Highlight matching HTML tags")
    ("utils/json-mode"
     :priority 60 :required nil :auto-load nil
     :depends ("utils/json-snatcher")
     :provides (json-mode)
     :version nil
     :upstream "https://github.com/joshwnj/json-mode"
     :description "JSON major mode")
    ("utils/json-snatcher"
     :priority 60 :required nil :auto-load nil
     :depends nil
     :provides (json-snatcher)
     :version nil
     :upstream "https://github.com/Sterlingg/json-snatcher"
     :description "Get JSON path")
    )
  "扩展注册表 V2，包含依赖管理、版本信息和元数据

每个条目格式为:
  (NAME :priority N :required BOOL :auto-load BOOL
        :depends (DEP1 DEP2 ...)
        :provides (FEATURE1 FEATURE2 ...)
        :version VERSION-STRING
        :upstream URL
        :description DESC)")

;; 向后兼容：创建旧格式的注册表视图
(defvar mcg-extension-registry
  (mapcar (lambda (entry)
            (let ((name (car entry))
                  (props (cdr entry)))
              (cons name
                    (list :priority (plist-get props :priority)
                          :required (plist-get props :required)
                          :auto-load (plist-get props :auto-load)))))
          mcg-extension-registry-v2)
  "扩展注册表（向后兼容视图）")
#+END_SRC

** Helper Functions
#+BEGIN_SRC emacs-lisp
;;; 辅助函数

(defun mcg-extension-enabled-p (extension-name)
  "检查扩展是否启用"
  (let ((extension (assoc extension-name mcg-extension-registry)))
    (and extension
         (not (plist-get (cdr extension) :disabled)))))

(defun mcg-extension-required-p (extension-name)
  "检查扩展是否必需"
  (let ((extension (assoc extension-name mcg-extension-registry)))
    (and extension
         (plist-get (cdr extension) :required))))

(defun mcg-extension-priority (extension-name)
  "获取扩展优先级"
  (let ((extension (assoc extension-name mcg-extension-registry)))
    (if extension
        (plist-get (cdr extension) :priority)
      999)))

(defun mcg-extension-auto-load-p (extension-name)
  "检查扩展是否自动加载"
  (let ((extension (assoc extension-name mcg-extension-registry)))
    (and extension
         (plist-get (cdr extension) :auto-load))))

(defun mcg-get-category-from-path (extension-path)
  "从扩展路径中提取类别
返回类别符号，如果路径格式不正确则返回 nil"
  (when (and extension-path
             (stringp extension-path)
             (string-match "^\\([^/]+\\)/" extension-path))
    (let ((category (intern (match-string 1 extension-path))))
      (when (memq category mcg-extension-categories)
        category))))
#+END_SRC

** Dependency Resolution Functions
#+BEGIN_SRC emacs-lisp
;;; 依赖解析函数

(defvar mcg--dependency-visited nil
  "用于循环依赖检测的已访问扩展列表")

(defun mcg-extension-get-v2 (extension-name)
  "从 V2 注册表获取扩展的完整属性
返回 plist 或 nil"
  (let ((entry (assoc extension-name mcg-extension-registry-v2)))
    (when entry
      (cdr entry))))

(defun mcg-extension-direct-depends (extension-name)
  "获取扩展的直接依赖列表"
  (let ((props (mcg-extension-get-v2 extension-name)))
    (when props
      (plist-get props :depends))))

(defun mcg-extension-dependencies (extension-name &optional visited)
  "递归解析扩展的所有依赖（包括传递依赖）

参数:
- EXTENSION-NAME: 扩展名称
- VISITED: 内部使用，用于循环依赖检测

返回依赖列表（按加载顺序排列，依赖在前）
如果检测到循环依赖，返回 nil 并发出警告"
  (let ((visited (or visited (list))))
    ;; 检测循环依赖
    (when (member extension-name visited)
      (message "Warning: Circular dependency detected: %s -> %s"
               (car visited) extension-name)
      (cl-return-from mcg-extension-dependencies nil))
    
    (let* ((direct-deps (mcg-extension-direct-depends extension-name))
           (all-deps '()))
      ;; 递归解析每个直接依赖
      (dolist (dep direct-deps)
        (let ((transitive-deps (mcg-extension-dependencies
                                dep
                                (cons extension-name visited))))
          ;; 添加传递依赖（避免重复）
          (dolist (td transitive-deps)
            (unless (member td all-deps)
              (push td all-deps)))
          ;; 添加直接依赖本身
          (unless (member dep all-deps)
            (push dep all-deps))))
      ;; 返回依赖列表（反转以保持正确顺序）
      (nreverse all-deps))))

(defun mcg-load-extension-with-deps (extension-name)
  "加载扩展及其所有依赖

参数:
- EXTENSION-NAME: 扩展名称

返回:
- t 如果加载成功
- nil 如果加载失败"
  (let ((deps (mcg-extension-dependencies extension-name)))
    ;; 先加载所有依赖
    (dolist (dep deps)
      (unless (mcg-load-extension dep)
        (message "Warning: Failed to load dependency %s for %s" dep extension-name)
        (unless (mcg-extension-required-p dep)
          ;; 可选依赖失败，继续
          nil)))
    ;; 最后加载扩展本身
    (mcg-load-extension extension-name)))

(defun mcg-check-circular-dependencies ()
  "检查注册表中是否存在循环依赖
返回循环依赖列表，如果没有则返回 nil"
  (interactive)
  (let ((cycles '()))
    (dolist (entry mcg-extension-registry-v2)
      (let* ((name (car entry))
             (deps (mcg-extension-dependencies name)))
        (when (null deps)
          ;; 如果返回 nil 且有直接依赖，说明有循环
          (when (mcg-extension-direct-depends name)
            (push name cycles)))))
    (when (called-interactively-p 'any)
      (if cycles
          (message "Circular dependencies found in: %s" cycles)
        (message "No circular dependencies found")))
    cycles))
#+END_SRC

** Extension Info Query Functions
#+BEGIN_SRC emacs-lisp
;;; 扩展信息查询函数

(defun mcg-extension-info (extension-name)
  "获取扩展的完整信息

参数:
- EXTENSION-NAME: 扩展名称

返回包含以下字段的 plist:
- :name        扩展名称
- :category    类别符号
- :priority    加载优先级
- :required    是否必需
- :depends     依赖列表
- :provides    提供的 feature 列表
- :version     版本号
- :upstream    上游 URL
- :description 描述
- :loaded      是否已加载
- :path        扩展路径
- :exists      路径是否存在"
  (let* ((props (mcg-extension-get-v2 extension-name))
         (category (mcg-get-category-from-path extension-name))
         (path (expand-file-name extension-name
                                 (expand-file-name "site-lisp/extensions"
                                                   mcgemacs-root-dir)))
         (exists (file-directory-p path))
         (loaded (member path load-path)))
    (when props
      (list :name extension-name
            :category category
            :priority (plist-get props :priority)
            :required (plist-get props :required)
            :depends (plist-get props :depends)
            :provides (plist-get props :provides)
            :version (plist-get props :version)
            :upstream (plist-get props :upstream)
            :description (plist-get props :description)
            :loaded (if loaded t nil)
            :path path
            :exists exists))))

(defun mcg-extension-info-string (extension-name)
  "获取扩展信息的格式化字符串"
  (let ((info (mcg-extension-info extension-name)))
    (if info
        (format "扩展: %s
类别: %s
优先级: %d
必需: %s
依赖: %s
提供: %s
版本: %s
上游: %s
描述: %s
已加载: %s
路径: %s
存在: %s"
                (plist-get info :name)
                (or (plist-get info :category) "未知")
                (or (plist-get info :priority) 999)
                (if (plist-get info :required) "是" "否")
                (or (mapconcat #'identity (plist-get info :depends) ", ") "无")
                (or (mapconcat #'symbol-name (plist-get info :provides) ", ") "无")
                (or (plist-get info :version) "未知")
                (or (plist-get info :upstream) "无")
                (or (plist-get info :description) "无描述")
                (if (plist-get info :loaded) "是" "否")
                (plist-get info :path)
                (if (plist-get info :exists) "是" "否"))
      (format "扩展 %s 未在注册表中找到" extension-name))))

(defun mcg-list-all-extensions ()
  "列出所有注册的扩展名称"
  (mapcar #'car mcg-extension-registry-v2))

(defun mcg-list-extensions-with-deps ()
  "列出所有有依赖的扩展"
  (seq-filter (lambda (entry)
                (plist-get (cdr entry) :depends))
              mcg-extension-registry-v2))

(defun mcg-list-required-extensions ()
  "列出所有必需的扩展"
  (seq-filter (lambda (entry)
                (plist-get (cdr entry) :required))
              mcg-extension-registry-v2))
#+END_SRC

** Load Extension Functions
#+BEGIN_SRC emacs-lisp
;;; 加载扩展函数

(defun mcg-load-extension (extension-name)
  "加载指定的扩展

  参数:
  - EXTENSION-NAME: 扩展名称（含类别路径，如 'core/dash' 或 'completion/vertico'）"
  (let* ((extension-path (file-name-as-directory
                          (expand-file-name extension-name
                                            (expand-file-name
                                             "site-lisp/extensions"
                                             mcgemacs-root-dir))))
         (extension (assoc extension-name mcg-extension-registry)))
    (condition-case err
        (when (file-directory-p extension-path)
          (add-to-list 'load-path extension-path)
          (when (and extension (mcg-extension-auto-load-p extension-name))
            ;; 如果注册了自动加载，尝试require
            (let ((feature-name (intern (file-name-nondirectory
                                         (directory-file-name extension-path)))))
              (require feature-name nil t)))
          t)
      (error
       (if (mcg-extension-required-p extension-name)
           (error "Required extension %s failed to load: %s"
                  extension-name
                  (error-message-string err))
         (message "Warning: Optional extension %s failed to load: %s"
                  extension-name
                  (error-message-string err))
         nil)))))

(defun mcg-load-core-extensions ()
  "加载核心扩展（必需的基础设施）"
  (dolist (extension-name (mapcar #'car
                                   (seq-filter (lambda (x)
                                                 (plist-get (cdr x) :required))
                                               mcg-extension-registry)))
    (mcg-load-extension extension-name)))

(defun mcg-load-extensions-by-category (category)
  "按类别加载扩展

  参数:
  - CATEGORY: 类别符号，如 'core, 'completion, 'editor 等"
  (let ((category-prefix (format "%s/" (symbol-name category))))
    (dolist (extension (seq-filter
                        (lambda (x)
                          (string-prefix-p category-prefix (car x)))
                        mcg-extension-registry))
      (mcg-load-extension (car extension)))))

(defun mcg-load-extensions-by-priority ()
  "按优先级加载所有扩展"
  (let ((sorted-extensions (sort (copy-sequence mcg-extension-registry)
                                 (lambda (a b)
                                   (< (plist-get (cdr a) :priority)
                                      (plist-get (cdr b) :priority))))))
    (dolist (extension sorted-extensions)
      (mcg-load-extension (car extension)))))
#+END_SRC

** Category Management
#+BEGIN_SRC emacs-lisp
;;; 类别管理

(defun mcg-list-extensions-by-category (category)
  "列出指定类别下的所有扩展

  参数:
  - CATEGORY: 类别符号"
  (let ((category-prefix (format "%s/" (symbol-name category))))
    (seq-filter
     (lambda (x)
       (string-prefix-p category-prefix (car x)))
     mcg-extension-registry)))

(defun mcg-category-loaded-p (category)
  "检查类别下的所有扩展是否已加载"
  (let ((extensions (mcg-list-extensions-by-category category)))
    (seq-every-p
     (lambda (ext)
       (let ((path (expand-file-name (car ext)
                                     (expand-file-name "site-lisp/extensions"
                                                       mcgemacs-root-dir))))
         (member path load-path)))
     extensions)))
#+END_SRC

** Initialize Load Path
#+BEGIN_SRC emacs-lisp
;;; 初始化加载路径

;; 1. 添加基础配置路径
(add-to-list 'load-path (expand-file-name "site-lisp/config" mcgemacs-root-dir))

;; 2. 批量添加所有 extensions 子目录到 load-path
;;    采用递归方式，自动发现所有子目录
(let ((extensions-root (expand-file-name "site-lisp/extensions" mcgemacs-root-dir)))
  (when (file-directory-p extensions-root)
    ;; 递归添加所有子目录
    (dolist (category mcg-extension-categories)
      (let ((category-dir (expand-file-name (symbol-name category) extensions-root)))
        (when (file-directory-p category-dir)
          ;; 添加类别目录自身
          (add-to-list 'load-path category-dir)
          
          ;; 添加类别下的所有子目录
          (dolist (subdir (directory-files category-dir t "^\\([^.]\\)"))
            (when (file-directory-p subdir)
              (add-to-list 'load-path subdir)
              
              ;; 处理二级子目录（如 lsp/clojure/）
              (dolist (sub-subdir (directory-files subdir t "^\\([^.]\\)"))
                (when (file-directory-p sub-subdir)
                  (add-to-list 'load-path sub-subdir))))))))))

;; 3. 添加遗留的直接在 extensions 下的目录（向后兼容）
(let ((extensions-dir (expand-file-name "site-lisp/extensions" mcgemacs-root-dir)))
  (when (file-directory-p extensions-dir)
    (dolist (subdir (directory-files extensions-dir t "^\\([^.]\\)"))
      (when (and (file-directory-p subdir)
                 (not (member (file-name-nondirectory subdir)
                              (mapcar #'symbol-name mcg-extension-categories))))
        (add-to-list 'load-path subdir)))))
#+END_SRC

** Interactive Commands
#+BEGIN_SRC emacs-lisp
;;; 交互命令

(defun mcg-reload-extension (extension-name)
  "重新加载指定扩展"
  (interactive
   (list (completing-read "重新加载扩展: "
                          (mcg-list-all-extensions)
                          nil t)))
  (mcg-load-extension extension-name)
  (message "已重新加载: %s" extension-name))

(defun mcg-load-category (category)
  "加载指定类别下的所有扩展"
  (interactive
   (list (intern (completing-read "加载类别: "
                                  (mapcar #'symbol-name mcg-extension-categories)
                                  nil t))))
  (mcg-load-extensions-by-category category)
  (message "已加载类别: %s" category))

(defun mcg-info-extension (extension-name)
  "显示扩展的详细信息

在 minibuffer 中显示扩展的完整信息，包括：
- 基本信息（名称、类别、优先级）
- 依赖关系
- 版本和上游信息
- 加载状态"
  (interactive
   (list (completing-read "查看扩展信息: "
                          (mcg-list-all-extensions)
                          nil t)))
  (let ((info-string (mcg-extension-info-string extension-name)))
    (if (called-interactively-p 'any)
        ;; 交互调用时，在新 buffer 中显示
        (let ((buffer (get-buffer-create "*Extension Info*")))
          (with-current-buffer buffer
            (erase-buffer)
            (insert info-string)
            (goto-char (point-min)))
          (display-buffer buffer))
      ;; 非交互调用时，返回字符串
      info-string)))

(defun mcg-show-extension-deps (extension-name)
  "显示扩展的依赖树"
  (interactive
   (list (completing-read "查看扩展依赖: "
                          (mcg-list-all-extensions)
                          nil t)))
  (let* ((deps (mcg-extension-dependencies extension-name))
         (direct-deps (mcg-extension-direct-depends extension-name)))
    (message "扩展 %s 的依赖:\n直接依赖: %s\n所有依赖: %s"
             extension-name
             (or (mapconcat #'identity direct-deps ", ") "无")
             (or (mapconcat #'identity deps ", ") "无"))))

(defun mcg-load-extension-interactive (extension-name)
  "交互式加载扩展（带依赖）"
  (interactive
   (list (completing-read "加载扩展（带依赖）: "
                          (mcg-list-all-extensions)
                          nil t)))
  (if (mcg-load-extension-with-deps extension-name)
      (message "已加载扩展及其依赖: %s" extension-name)
    (message "加载扩展失败: %s" extension-name)))
#+END_SRC

** Phased Loading System (分阶段加载系统)

分阶段加载系统将扩展按类别分组到不同的加载阶段，支持延迟加载以优化启动性能。

*** Load Phase Definitions
#+BEGIN_SRC emacs-lisp
;;; ============================================================
;;; 分阶段加载系统 (Phased Loading System)
;;; ============================================================

;;; 加载阶段定义

(defvar mcg-load-phases
  '((phase-1 . (core))              ; 核心库
    (phase-2 . (ui))                ; 用户界面
    (phase-3 . (editor completion snippets)) ; 编辑器、补全和代码片段
    (phase-4 . (search utils input)) ; 搜索、工具和输入
    (phase-5 . (lsp git))           ; LSP 和 Git（延迟）
    (phase-6 . (org docs)))         ; Org 和文档（延迟）
  "加载阶段定义

每个阶段包含一组类别，按顺序加载。
前4个阶段在启动时立即加载，后2个阶段延迟加载。")

(defvar mcg-phase-timing nil
  "记录每个阶段的加载时间

格式: ((phase-1 . TIME) (phase-2 . TIME) ...)")

(defvar mcg-current-phase nil
  "当前正在加载的阶段")

(defvar mcg-phases-loaded nil
  "已完成加载的阶段列表")
#+END_SRC

*** Deferred Loading Configuration
#+BEGIN_SRC emacs-lisp
;;; 延迟加载配置

(defvar mcg-deferred-categories '(lsp git org docs)
  "延迟加载的类别

这些类别不会在启动时立即加载，而是在 Emacs 空闲时加载。")

(defvar mcg-defer-time 1.0
  "延迟加载等待时间（秒）

在 Emacs 启动后等待此时间再开始加载延迟类别。")

(defvar mcg-deferred-load-timer nil
  "延迟加载定时器")

(defvar mcg-deferred-load-complete nil
  "延迟加载是否已完成")
#+END_SRC

*** Phase Loading Functions
#+BEGIN_SRC emacs-lisp
;;; 阶段加载函数

(defun mcg-phase-categories (phase)
  "获取指定阶段包含的类别列表

参数:
- PHASE: 阶段符号，如 'phase-1

返回类别符号列表"
  (cdr (assoc phase mcg-load-phases)))

(defun mcg-phase-deferred-p (phase)
  "检查阶段是否为延迟加载阶段

参数:
- PHASE: 阶段符号

返回 t 如果阶段包含延迟类别"
  (let ((categories (mcg-phase-categories phase)))
    (seq-some (lambda (cat) (memq cat mcg-deferred-categories))
              categories)))

(defun mcg-load-phase (phase)
  "加载指定阶段的所有扩展

参数:
- PHASE: 阶段符号，如 'phase-1

返回:
- 加载耗时（秒）

此函数会:
1. 记录开始时间
2. 按优先级加载阶段内所有类别的扩展
3. 记录结束时间并保存到 `mcg-phase-timing'
4. 将阶段添加到 `mcg-phases-loaded'"
  (let ((start-time (current-time))
        (categories (mcg-phase-categories phase)))
    (setq mcg-current-phase phase)
    
    ;; 按类别加载扩展
    (dolist (category categories)
      (mcg-load-extensions-by-category category))
    
    ;; 计算并记录耗时
    (let ((elapsed (float-time (time-subtract (current-time) start-time))))
      (push (cons phase elapsed) mcg-phase-timing)
      (push phase mcg-phases-loaded)
      (setq mcg-current-phase nil)
      
      ;; 返回耗时
      elapsed)))

(defun mcg-load-immediate-phases ()
  "加载所有非延迟阶段

返回总耗时（秒）"
  (let ((total-time 0))
    (dolist (phase-entry mcg-load-phases)
      (let ((phase (car phase-entry)))
        (unless (mcg-phase-deferred-p phase)
          (setq total-time (+ total-time (mcg-load-phase phase))))))
    total-time))
#+END_SRC

*** Deferred Loading Mechanism
#+BEGIN_SRC emacs-lisp
;;; 延迟加载机制

(defun mcg-schedule-deferred-load ()
  "安排延迟加载任务

在 `mcg-defer-time' 秒后开始加载延迟类别。
使用 idle timer 确保不影响用户操作。"
  (when mcg-deferred-load-timer
    (cancel-timer mcg-deferred-load-timer))
  
  (setq mcg-deferred-load-timer
        (run-with-idle-timer
         mcg-defer-time
         nil
         #'mcg-execute-deferred-load)))

(defun mcg-execute-deferred-load ()
  "执行延迟加载

加载所有延迟阶段的扩展。"
  (unless mcg-deferred-load-complete
    (let ((start-time (current-time)))
      ;; 加载所有延迟阶段
      (dolist (phase-entry mcg-load-phases)
        (let ((phase (car phase-entry)))
          (when (and (mcg-phase-deferred-p phase)
                     (not (memq phase mcg-phases-loaded)))
            (mcg-load-phase phase))))
      
      (setq mcg-deferred-load-complete t)
      
      ;; 显示延迟加载完成信息
      (let ((elapsed (float-time (time-subtract (current-time) start-time))))
        (message "Deferred loading completed in %.2f seconds" elapsed)))))

(defun mcg-cancel-deferred-load ()
  "取消延迟加载任务"
  (when mcg-deferred-load-timer
    (cancel-timer mcg-deferred-load-timer)
    (setq mcg-deferred-load-timer nil)))
#+END_SRC

*** Minimal Dependency Loading
#+BEGIN_SRC emacs-lisp
;;; 最小依赖加载

(defun mcg-load-extension-minimal (extension-name)
  "最小依赖加载扩展

只加载扩展及其必要的传递依赖，不加载同类别的其他扩展。

参数:
- EXTENSION-NAME: 扩展名称

返回:
- t 如果加载成功
- nil 如果加载失败"
  (let* ((deps (mcg-extension-dependencies extension-name))
         (loaded-count 0))
    ;; 先加载所有依赖
    (dolist (dep deps)
      (when (mcg-load-extension dep)
        (setq loaded-count (1+ loaded-count))))
    
    ;; 最后加载扩展本身
    (when (mcg-load-extension extension-name)
      (setq loaded-count (1+ loaded-count)))
    
    ;; 返回是否成功
    (> loaded-count 0)))
#+END_SRC

*** Load Status Report
#+BEGIN_SRC emacs-lisp
;;; 加载状态报告

(defun mcg-load-status ()
  "返回当前加载状态报告

返回 plist 包含:
- :phases-loaded    已加载的阶段列表
- :current-phase    当前正在加载的阶段
- :phase-timing     各阶段耗时
- :deferred-complete 延迟加载是否完成
- :total-time       总加载时间"
  (let ((total-time (apply #'+ (mapcar #'cdr mcg-phase-timing))))
    (list :phases-loaded mcg-phases-loaded
          :current-phase mcg-current-phase
          :phase-timing (reverse mcg-phase-timing)
          :deferred-complete mcg-deferred-load-complete
          :total-time total-time)))

(defun mcg-display-load-status ()
  "显示加载状态报告"
  (interactive)
  (let* ((status (mcg-load-status))
         (buffer (get-buffer-create "*Load Status*")))
    (with-current-buffer buffer
      (erase-buffer)
      (insert "Emacs 扩展加载状态\n")
      (insert "====================\n\n")
      
      ;; 阶段加载状态
      (insert "加载阶段:\n")
      (dolist (phase-entry mcg-load-phases)
        (let* ((phase (car phase-entry))
               (categories (cdr phase-entry))
               (loaded (memq phase (plist-get status :phases-loaded)))
               (timing (cdr (assoc phase (plist-get status :phase-timing)))))
          (insert (format "  %s [%s] %s"
                          (symbol-name phase)
                          (if loaded "✓" " ")
                          (mapconcat #'symbol-name categories ", ")))
          (when timing
            (insert (format " (%.2fs)" timing)))
          (insert "\n")))
      
      (insert "\n")
      
      ;; 延迟加载状态
      (insert (format "延迟加载: %s\n"
                      (if (plist-get status :deferred-complete)
                          "已完成"
                        "等待中")))
      
      ;; 总时间
      (insert (format "总加载时间: %.2f 秒\n"
                      (plist-get status :total-time)))
      
      (insert "\n按 'q' 关闭此窗口")
      (goto-char (point-min)))
    (display-buffer buffer)))
#+END_SRC

*** Deferred Extension Filtering
#+BEGIN_SRC emacs-lisp
;;; 初始化时排除延迟类别

(defun mcg-is-deferred-extension-p (extension-name)
  "检查扩展是否属于延迟加载类别

参数:
- EXTENSION-NAME: 扩展名称

返回 t 如果扩展属于延迟类别"
  (let ((category (mcg-get-category-from-path extension-name)))
    (memq category mcg-deferred-categories)))

(defun mcg-filter-deferred-from-load-path ()
  "从 load-path 中移除延迟加载类别的扩展

在初始化完成后调用，确保延迟包不在初始 load-path 中。"
  (let ((extensions-root (expand-file-name "site-lisp/extensions" mcgemacs-root-dir)))
    (setq load-path
          (seq-filter
           (lambda (path)
             (if (string-prefix-p extensions-root path)
                 ;; 检查是否为延迟类别
                 (let* ((relative (substring path (1+ (length extensions-root))))
                        (category (mcg-get-category-from-path relative)))
                   (not (memq category mcg-deferred-categories)))
               ;; 非扩展路径，保留
               t))
           load-path))))
#+END_SRC

** Version Manager (版本管理器)

版本管理器提供 Git Submodule 版本锁定、恢复和回滚功能。

*** Lock File Format
#+BEGIN_SRC emacs-lisp
;;; ============================================================
;;; 版本管理器 (Version Manager)
;;; ============================================================

;;; 锁文件格式定义

(defvar mcg-lock-file-path
  (expand-file-name "site-lisp/packages-lock.el" mcgemacs-root-dir)
  "版本锁定文件路径")

(defvar mcg-packages-lock nil
  "当前加载的版本锁定数据

格式: ((NAME . COMMIT-HASH) ...)")

(defvar mcg-lock-metadata nil
  "锁文件元数据

格式: (:locked-at TIMESTAMP :emacs-version VERSION :platform PLATFORM)")
#+END_SRC

*** Version Locking Functions
#+BEGIN_SRC emacs-lisp
;;; 版本锁定函数

(defun mcg-get-extension-commit (extension-name)
  "获取扩展的当前 Git commit hash

参数:
- EXTENSION-NAME: 扩展名称

返回 commit hash 字符串，如果失败返回 nil"
  (let* ((extension-path (expand-file-name
                          extension-name
                          (expand-file-name "site-lisp/extensions"
                                            mcgemacs-root-dir)))
         (default-directory extension-path))
    (when (and (file-directory-p extension-path)
               (file-directory-p (expand-file-name ".git" extension-path)))
      (condition-case nil
          (string-trim
           (shell-command-to-string "git rev-parse HEAD"))
        (error nil)))))

(defun mcg-get-extension-branch (extension-name)
  "获取扩展的当前 Git 分支名

参数:
- EXTENSION-NAME: 扩展名称

返回分支名字符串，如果是 detached HEAD 返回 nil"
  (let* ((extension-path (expand-file-name
                          extension-name
                          (expand-file-name "site-lisp/extensions"
                                            mcgemacs-root-dir)))
         (default-directory extension-path))
    (when (file-directory-p extension-path)
      (condition-case nil
          (let ((branch (string-trim
                         (shell-command-to-string
                          "git symbolic-ref --short HEAD 2>/dev/null"))))
            (unless (string-empty-p branch)
              branch))
        (error nil)))))

(defun mcg-collect-all-versions ()
  "收集所有扩展的版本信息

返回 alist: ((NAME . (:commit HASH :branch BRANCH)) ...)"
  (let ((versions '()))
    (dolist (entry mcg-extension-registry-v2)
      (let* ((name (car entry))
             (commit (mcg-get-extension-commit name))
             (branch (mcg-get-extension-branch name)))
        (when commit
          (push (cons name (list :commit commit :branch branch))
                versions))))
    (nreverse versions)))

(defun mcg-generate-lock-file-content (versions)
  "生成锁文件内容

参数:
- VERSIONS: 版本信息 alist

返回锁文件内容字符串"
  (let ((timestamp (format-time-string "%Y-%m-%dT%H:%M:%S%z"))
        (emacs-ver emacs-version)
        (platform (symbol-name system-type)))
    (concat
     ";;; packages-lock.el --- Locked package versions -*- lexical-binding: t; -*-\n\n"
     ";; Filename: packages-lock.el\n"
     ";; Description: Locked extension package versions\n"
     (format ";; Auto-generated: %s\n" timestamp)
     ";; DO NOT EDIT - This file is auto-generated by mcg-lock-packages\n\n"
     ";;; Commentary:\n;;\n"
     ";; This file records all Git Submodules commit hashes.\n"
     ";; Used for version control and rollback.\n;;\n\n"
     ";;; Code:\n\n"
     "(defvar mcg-packages-lock\n  '(\n"
     (mapconcat
      (lambda (entry)
        (let* ((name (car entry))
               (props (cdr entry))
               (commit (plist-get props :commit))
               (branch (plist-get props :branch)))
          (format "    (\"%s\" :commit \"%s\"%s)"
                  name
                  commit
                  (if branch (format " :branch \"%s\"" branch) ""))))
      versions
      "\n")
     "\n    )\n"
     "  \"Locked package versions with commit hashes and branch info\")\n\n"
     "(defvar mcg-lock-metadata\n"
     (format "  '(:locked-at \"%s\"\n" timestamp)
     (format "    :emacs-version \"%s\"\n" emacs-ver)
     (format "    :platform \"%s\")\n" platform)
     "  \"Lock file metadata\")\n\n"
     "(provide 'mcg-packages-lock)\n"
     ";;; packages-lock.el ends here\n")))

(defun mcg-lock-packages ()
  "锁定当前所有扩展的版本

将所有 Git Submodule 的 commit hash 保存到锁文件。
锁文件路径: site-lisp/packages-lock.el

返回锁定的包数量"
  (interactive)
  (let* ((versions (mcg-collect-all-versions))
         (content (mcg-generate-lock-file-content versions))
         (count (length versions)))
    (with-temp-file mcg-lock-file-path
      (insert content))
    (when (called-interactively-p 'any)
      (message "Locked %d package versions to %s" count mcg-lock-file-path))
    count))
#+END_SRC

*** Version Restore Functions
#+BEGIN_SRC emacs-lisp
;;; 版本恢复函数

(defun mcg-load-lock-file ()
  "加载锁文件

返回 t 如果成功加载，nil 如果文件不存在或加载失败"
  (when (file-exists-p mcg-lock-file-path)
    (condition-case err
        (progn
          (load mcg-lock-file-path nil t)
          t)
      (error
       (message "Failed to load lock file: %s" (error-message-string err))
       nil))))

(defun mcg-get-locked-version (extension-name)
  "获取扩展的锁定版本

参数:
- EXTENSION-NAME: 扩展名称

返回 plist (:commit HASH :branch BRANCH) 或 nil"
  (unless mcg-packages-lock
    (mcg-load-lock-file))
  (cdr (assoc extension-name mcg-packages-lock)))

(defun mcg-restore-package (extension-name)
  "恢复单个扩展到锁定版本

参数:
- EXTENSION-NAME: 扩展名称

返回:
- 'restored 如果成功恢复
- 'already-at-target 如果已经在目标版本
- 'dirty 如果有未提交更改
- 'not-found 如果扩展不存在
- 'no-lock 如果没有锁定版本
- 'failed 如果恢复失败"
  (let* ((locked (mcg-get-locked-version extension-name))
         (target-commit (plist-get locked :commit))
         (extension-path (expand-file-name
                          extension-name
                          (expand-file-name "site-lisp/extensions"
                                            mcgemacs-root-dir)))
         (default-directory extension-path))
    (cond
     ((not locked) 'no-lock)
     ((not (file-directory-p extension-path)) 'not-found)
     (t
      (let ((current-commit (mcg-get-extension-commit extension-name)))
        (cond
         ((string= current-commit target-commit) 'already-at-target)
         ;; 检查是否有未提交更改
         ((not (string-empty-p
                (string-trim
                 (shell-command-to-string "git status --porcelain 2>/dev/null"))))
          'dirty)
         ;; 执行 checkout
         (t
          (let ((result (shell-command-to-string
                         (format "git checkout %s 2>&1" target-commit))))
            (if (string-match-p "error\\|fatal" result)
                'failed
              'restored)))))))))

(defun mcg-restore-packages (&optional force)
  "恢复所有扩展到锁定版本

参数:
- FORCE: 如果为 t，跳过确认提示

返回恢复统计 plist:
(:restored N :skipped N :failed N :total N)"
  (interactive "P")
  (unless (mcg-load-lock-file)
    (user-error "Lock file not found: %s\nRun mcg-lock-packages first"
                mcg-lock-file-path))
  
  (let ((restored 0)
        (skipped 0)
        (failed 0)
        (total (length mcg-packages-lock)))
    
    (unless force
      (unless (yes-or-no-p (format "Restore %d packages to locked versions? " total))
        (user-error "Operation cancelled")))
    
    (dolist (entry mcg-packages-lock)
      (let* ((name (car entry))
             (result (mcg-restore-package name)))
        (pcase result
          ('restored (setq restored (1+ restored))
                     (message "[OK] %s restored" name))
          ('already-at-target (setq skipped (1+ skipped))
                              (message "[=] %s already at target" name))
          ('dirty (setq skipped (1+ skipped))
                  (message "[!] %s has local changes, skipped" name))
          ('not-found (setq skipped (1+ skipped))
                      (message "[!] %s not found, skipped" name))
          ('no-lock (setq skipped (1+ skipped)))
          ('failed (setq failed (1+ failed))
                   (message "[X] %s restore failed" name)))))
    
    (message "Restore complete: %d restored, %d skipped, %d failed (total: %d)"
             restored skipped failed total)
    
    (list :restored restored :skipped skipped :failed failed :total total)))
#+END_SRC

*** Single Package Rollback
#+BEGIN_SRC emacs-lisp
;;; 单包回滚函数

(defun mcg-rollback-package (extension-name &optional commit)
  "回滚单个扩展到指定版本

参数:
- EXTENSION-NAME: 扩展名称
- COMMIT: 目标 commit hash（可选，默认使用锁定版本）

返回:
- t 如果成功
- nil 如果失败"
  (interactive
   (let* ((name (completing-read "Rollback package: "
                                 (mcg-list-all-extensions)
                                 nil t))
          (locked (mcg-get-locked-version name))
          (default-commit (plist-get locked :commit))
          (commit (read-string
                   (format "Target commit (default: %s): "
                           (if default-commit
                               (substring default-commit 0 7)
                             "none"))
                   nil nil default-commit)))
     (list name commit)))
  
  (let* ((extension-path (expand-file-name
                          extension-name
                          (expand-file-name "site-lisp/extensions"
                                            mcgemacs-root-dir)))
         (default-directory extension-path))
    (unless (file-directory-p extension-path)
      (user-error "Extension not found: %s" extension-name))
    
    (unless commit
      (user-error "No commit specified and no locked version available"))
    
    ;; 检查是否有未提交更改
    (let ((status (string-trim
                   (shell-command-to-string "git status --porcelain 2>/dev/null"))))
      (unless (string-empty-p status)
        (user-error "Extension %s has uncommitted changes. Commit or stash first"
                    extension-name)))
    
    ;; 执行回滚
    (let ((result (shell-command-to-string
                   (format "git checkout %s 2>&1" commit))))
      (if (string-match-p "error\\|fatal" result)
          (progn
            (message "Rollback failed: %s" result)
            nil)
        (message "Rolled back %s to %s" extension-name (substring commit 0 7))
        t))))
#+END_SRC

*** Version Comparison
#+BEGIN_SRC emacs-lisp
;;; 版本比较函数

(defun mcg-compare-versions ()
  "比较当前版本与锁定版本的差异

显示哪些扩展的版本与锁定版本不同。"
  (interactive)
  (unless (mcg-load-lock-file)
    (user-error "Lock file not found: %s" mcg-lock-file-path))
  
  (let ((buffer (get-buffer-create "*Version Comparison*"))
        (changed '())
        (same '())
        (missing '()))
    
    (dolist (entry mcg-packages-lock)
      (let* ((name (car entry))
             (locked-commit (plist-get (cdr entry) :commit))
             (current-commit (mcg-get-extension-commit name)))
        (cond
         ((not current-commit)
          (push name missing))
         ((string= current-commit locked-commit)
          (push name same))
         (t
          (push (list name
                      :locked (substring locked-commit 0 7)
                      :current (substring current-commit 0 7))
                changed)))))
    
    (with-current-buffer buffer
      (erase-buffer)
      (insert "版本比较报告\n")
      (insert "====================\n\n")
      
      (insert (format "锁定时间: %s\n"
                      (or (plist-get mcg-lock-metadata :locked-at) "未知")))
      (insert (format "锁定平台: %s\n\n"
                      (or (plist-get mcg-lock-metadata :platform) "未知")))
      
      ;; 显示变更的包
      (when changed
        (insert (format "已变更 (%d):\n" (length changed)))
        (dolist (item (nreverse changed))
          (insert (format "  %s: %s -> %s\n"
                          (car item)
                          (plist-get (cdr item) :locked)
                          (plist-get (cdr item) :current))))
        (insert "\n"))
      
      ;; 显示缺失的包
      (when missing
        (insert (format "缺失 (%d):\n" (length missing)))
        (dolist (name (nreverse missing))
          (insert (format "  %s\n" name)))
        (insert "\n"))
      
      ;; 显示未变更的包数量
      (insert (format "未变更: %d 个包\n" (length same)))
      
      (insert "\n按 'q' 关闭此窗口")
      (goto-char (point-min)))
    
    (display-buffer buffer)))

(defun mcg-check-lock-file-exists ()
  "检查锁文件是否存在

如果不存在，提示用户创建。"
  (interactive)
  (if (file-exists-p mcg-lock-file-path)
      (message "Lock file exists: %s" mcg-lock-file-path)
    (when (yes-or-no-p "Lock file not found. Create one now? ")
      (mcg-lock-packages))))
#+END_SRC

** Search and Navigation Functions
#+BEGIN_SRC emacs-lisp
;;; ============================================================
;;; 搜索和导航功能 (Search and Navigation)
;;; ============================================================

;;; 模糊搜索函数

(defun mcg-fuzzy-match-p (query target)
  "检查 QUERY 是否模糊匹配 TARGET

模糊匹配规则:
1. 如果 QUERY 是 TARGET 的子串，匹配成功
2. 如果 QUERY 的所有字符按顺序出现在 TARGET 中，匹配成功
3. 匹配不区分大小写

参数:
- QUERY: 搜索查询字符串
- TARGET: 目标字符串

返回 t 如果匹配成功，nil 否则"
  (when (and query target
             (stringp query)
             (stringp target)
             (> (length query) 0)
             (> (length target) 0))
    (let ((query-lower (downcase query))
          (target-lower (downcase target)))
      (or
       ;; 子串匹配
       (string-match-p (regexp-quote query-lower) target-lower)
       ;; 字符顺序匹配
       (let ((query-chars (string-to-list query-lower))
             (target-pos 0)
             (matched t))
         (catch 'no-match
           (dolist (char query-chars)
             (let ((found-pos (cl-position char target-lower :start target-pos)))
               (if found-pos
                   (setq target-pos (1+ found-pos))
                 (throw 'no-match nil))))
           t))))))

(defun mcg-search-extension (query)
  "模糊搜索扩展

支持按名称和类别模糊匹配。

参数:
- QUERY: 搜索查询字符串

返回匹配的扩展名称列表，按相关性排序:
1. 名称完全匹配
2. 名称前缀匹配
3. 名称子串匹配
4. 类别匹配
5. 描述匹配"
  (interactive "s搜索扩展: ")
  (when (and query (> (length query) 0))
    (let ((results '())
          (query-lower (downcase query)))
      ;; 遍历所有扩展
      (dolist (entry mcg-extension-registry-v2)
        (let* ((name (car entry))
               (props (cdr entry))
               (name-lower (downcase name))
               (category (mcg-get-category-from-path name))
               (category-str (when category (symbol-name category)))
               (description (plist-get props :description))
               (score 0))
          
          ;; 计算匹配分数
          (cond
           ;; 名称完全匹配 (最高优先级)
           ((string= query-lower name-lower)
            (setq score 100))
           ;; 名称前缀匹配
           ((string-prefix-p query-lower name-lower)
            (setq score 80))
           ;; 名称子串匹配
           ((string-match-p (regexp-quote query-lower) name-lower)
            (setq score 60))
           ;; 类别匹配
           ((and category-str
                 (string-match-p (regexp-quote query-lower) (downcase category-str)))
            (setq score 40))
           ;; 描述匹配
           ((and description
                 (string-match-p (regexp-quote query-lower) (downcase description)))
            (setq score 20))
           ;; 模糊字符匹配
           ((mcg-fuzzy-match-p query name)
            (setq score 10)))
          
          ;; 如果有匹配，添加到结果
          (when (> score 0)
            (push (cons name score) results))))
      
      ;; 按分数排序并返回名称列表
      (let ((sorted-results
             (mapcar #'car
                     (sort results
                           (lambda (a b) (> (cdr a) (cdr b)))))))
        (when (called-interactively-p 'any)
          (if sorted-results
              (let ((buffer (get-buffer-create "*Extension Search*")))
                (with-current-buffer buffer
                  (erase-buffer)
                  (insert (format "搜索结果: \"%s\"\n" query))
                  (insert "====================\n\n")
                  (insert (format "找到 %d 个匹配:\n\n" (length sorted-results)))
                  (dolist (name sorted-results)
                    (let* ((info (mcg-extension-info name))
                           (category (plist-get info :category))
                           (description (plist-get info :description))
                           (loaded (plist-get info :loaded)))
                      (insert (format "  %s%s\n"
                                      name
                                      (if loaded " [已加载]" "")))
                      (insert (format "    类别: %s\n" (or category "未知")))
                      (when description
                        (insert (format "    描述: %s\n" description)))
                      (insert "\n")))
                  (insert "按 'q' 关闭此窗口")
                  (goto-char (point-min)))
                (display-buffer buffer))
            (message "未找到匹配 \"%s\" 的扩展" query)))
        sorted-results))))

(defun mcg-search-extension-interactive ()
  "交互式搜索扩展并选择

使用 completing-read 让用户选择搜索结果。"
  (interactive)
  (let* ((query (read-string "搜索扩展: "))
         (results (mcg-search-extension query)))
    (if results
        (let ((selected (completing-read "选择扩展: " results nil t)))
          (mcg-info-extension selected))
      (message "未找到匹配 \"%s\" 的扩展" query))))
#+END_SRC

** Category Statistics and Enhanced Display
#+BEGIN_SRC emacs-lisp
;;; 类别统计和增强显示

(defun mcg-category-statistics (category)
  "获取类别的统计信息

参数:
- CATEGORY: 类别符号

返回 plist 包含:
- :total       扩展总数
- :loaded      已加载数
- :required    必需扩展数
- :with-deps   有依赖的扩展数
- :deferred    是否为延迟类别"
  (let* ((extensions (mcg-list-extensions-by-category category))
         (total (length extensions))
         (loaded 0)
         (required 0)
         (with-deps 0))
    (dolist (ext extensions)
      (let* ((name (car ext))
             (props (cdr ext))
             (path (expand-file-name name
                                     (expand-file-name "site-lisp/extensions"
                                                       mcgemacs-root-dir))))
        (when (member path load-path)
          (setq loaded (1+ loaded)))
        (when (plist-get props :required)
          (setq required (1+ required)))
        (when (plist-get props :depends)
          (setq with-deps (1+ with-deps)))))
    (list :total total
          :loaded loaded
          :required required
          :with-deps with-deps
          :deferred (memq category mcg-deferred-categories))))

(defun mcg-display-categories-status ()
  "显示所有类别的加载状态

增强版本，包含:
- 类别描述
- 加载统计（已加载/总数）
- 必需扩展数
- 有依赖的扩展数
- 延迟加载标记"
  (interactive)
  (let ((buffer (get-buffer-create "*Extension Categories*")))
    (with-current-buffer buffer
      (erase-buffer)
      (insert "Emacs 扩展类别状态\n")
      (insert "====================\n\n")
      
      ;; 表头
      (insert (format "%-12s %-10s %-8s %-8s %-8s %s\n"
                      "类别" "加载状态" "必需" "有依赖" "延迟" "描述"))
      (insert (make-string 80 ?-))
      (insert "\n")
      
      ;; 统计总数
      (let ((total-extensions 0)
            (total-loaded 0)
            (total-required 0))
        
        (dolist (category mcg-extension-categories)
          (let* ((stats (mcg-category-statistics category))
                 (total (plist-get stats :total))
                 (loaded (plist-get stats :loaded))
                 (required (plist-get stats :required))
                 (with-deps (plist-get stats :with-deps))
                 (deferred (plist-get stats :deferred))
                 (description (cdr (assoc category mcg-category-descriptions))))
            
            ;; 累计总数
            (setq total-extensions (+ total-extensions total))
            (setq total-loaded (+ total-loaded loaded))
            (setq total-required (+ total-required required))
            
            ;; 显示类别行
            (insert (format "%-12s [%2d/%-2d]   %-8d %-8d %-8s %s\n"
                            (upcase (symbol-name category))
                            loaded total
                            required
                            with-deps
                            (if deferred "是" "-")
                            (or description "")))))
        
        ;; 分隔线
        (insert (make-string 80 ?-))
        (insert "\n")
        
        ;; 总计
        (insert (format "%-12s [%2d/%-2d]   %-8d\n"
                        "总计"
                        total-loaded total-extensions
                        total-required)))
      
      (insert "\n")
      (insert "说明:\n")
      (insert "  - 加载状态: [已加载/总数]\n")
      (insert "  - 必需: 标记为必需的扩展数量\n")
      (insert "  - 有依赖: 有依赖关系的扩展数量\n")
      (insert "  - 延迟: 是否为延迟加载类别\n")
      (insert "\n按 'q' 关闭此窗口")
      (goto-char (point-min)))
    (display-buffer buffer)))

(defun mcg-display-category-extensions (category)
  "显示指定类别下的所有扩展详情

参数:
- CATEGORY: 类别符号"
  (interactive
   (list (intern (completing-read "选择类别: "
                                  (mapcar #'symbol-name mcg-extension-categories)
                                  nil t))))
  (let* ((extensions (mcg-list-extensions-by-category category))
         (description (cdr (assoc category mcg-category-descriptions)))
         (buffer (get-buffer-create (format "*Category: %s*" category))))
    (with-current-buffer buffer
      (erase-buffer)
      (insert (format "类别: %s\n" (upcase (symbol-name category))))
      (insert (format "描述: %s\n" (or description "无描述")))
      (insert (format "扩展数量: %d\n" (length extensions)))
      (insert "====================\n\n")
      
      ;; 按优先级排序
      (let ((sorted-extensions
             (sort (copy-sequence extensions)
                   (lambda (a b)
                     (< (or (plist-get (cdr a) :priority) 999)
                        (or (plist-get (cdr b) :priority) 999))))))
        (dolist (ext sorted-extensions)
          (let* ((name (car ext))
                 (props (cdr ext))
                 (path (expand-file-name name
                                         (expand-file-name "site-lisp/extensions"
                                                           mcgemacs-root-dir)))
                 (loaded (member path load-path))
                 (required (plist-get props :required))
                 (depends (plist-get props :depends))
                 (desc (plist-get props :description)))
            (insert (format "%s %s%s\n"
                            (if loaded "[✓]" "[ ]")
                            name
                            (if required " *必需*" "")))
            (when desc
              (insert (format "    %s\n" desc)))
            (when depends
              (insert (format "    依赖: %s\n" (mapconcat #'identity depends ", "))))
            (insert "\n"))))
      
      (insert "按 'q' 关闭此窗口")
      (goto-char (point-min)))
    (display-buffer buffer)))
#+END_SRC

** Platform Detection and Cross-Platform Compatibility
#+BEGIN_SRC emacs-lisp
;;; ============================================================
;;; 跨平台兼容性 (Cross-Platform Compatibility)
;;; ============================================================

;;; 平台检测变量

(defvar mcg-current-platform nil
  "当前检测到的平台

可能的值:
- 'windows    Windows 系统
- 'macos      macOS 系统
- 'linux      Linux 系统
- 'bsd        BSD 系统
- 'unknown    未知系统")

(defvar mcg-platform-info nil
  "平台详细信息 plist

包含:
- :platform      平台符号
- :system-type   Emacs system-type
- :path-sep      路径分隔符
- :line-ending   行尾符
- :shell         默认 shell
- :home          用户主目录")

;;; 平台检测函数

(defun mcg-detect-platform ()
  "检测当前运行平台

设置 `mcg-current-platform' 和 `mcg-platform-info'

返回平台符号"
  (let ((platform
         (pcase system-type
           ('windows-nt 'windows)
           ('darwin 'macos)
           ('gnu/linux 'linux)
           ((or 'berkeley-unix 'gnu/kfreebsd) 'bsd)
           (_ 'unknown))))
    
    (setq mcg-current-platform platform)
    
    (setq mcg-platform-info
          (list :platform platform
                :system-type system-type
                :path-sep (if (eq platform 'windows) "\\" "/")
                :line-ending (if (eq platform 'windows) "\r\n" "\n")
                :shell (or (getenv "SHELL")
                           (if (eq platform 'windows) "cmd.exe" "/bin/sh"))
                :home (expand-file-name "~")))
    
    platform))

(defun mcg-platform-windows-p ()
  "检查是否为 Windows 平台"
  (unless mcg-current-platform
    (mcg-detect-platform))
  (eq mcg-current-platform 'windows))

(defun mcg-platform-macos-p ()
  "检查是否为 macOS 平台"
  (unless mcg-current-platform
    (mcg-detect-platform))
  (eq mcg-current-platform 'macos))

(defun mcg-platform-linux-p ()
  "检查是否为 Linux 平台"
  (unless mcg-current-platform
    (mcg-detect-platform))
  (eq mcg-current-platform 'linux))

(defun mcg-platform-unix-like-p ()
  "检查是否为类 Unix 平台（Linux, macOS, BSD）"
  (unless mcg-current-platform
    (mcg-detect-platform))
  (memq mcg-current-platform '(linux macos bsd)))

(defun mcg-get-path-separator ()
  "获取当前平台的路径分隔符"
  (unless mcg-platform-info
    (mcg-detect-platform))
  (plist-get mcg-platform-info :path-sep))

(defun mcg-normalize-path (path)
  "规范化路径，使用当前平台的路径分隔符

参数:
- PATH: 要规范化的路径

返回规范化后的路径字符串"
  (when path
    (let ((normalized (expand-file-name path)))
      (if (mcg-platform-windows-p)
          ;; Windows: 确保使用反斜杠
          (replace-regexp-in-string "/" "\\\\" normalized)
        ;; Unix-like: 确保使用正斜杠
        (replace-regexp-in-string "\\\\" "/" normalized)))))
#+END_SRC

** External Tools Detection
#+BEGIN_SRC emacs-lisp
;;; 外部工具检测

(defvar mcg-external-tools-cache nil
  "外部工具路径缓存

格式: ((tool-name . path-or-nil) ...)")

(defvar mcg-required-tools
  '((git . "git")
    (ripgrep . ("rg" "ripgrep"))
    (python . ("python3" "python"))
    (node . ("node" "nodejs"))
    (fd . ("fd" "fd-find"))
    (fzf . "fzf"))
  "需要检测的外部工具列表

格式: ((TOOL-SYMBOL . EXECUTABLE-NAME-OR-LIST) ...)")

(defun mcg-find-executable (name)
  "查找可执行文件路径

参数:
- NAME: 可执行文件名或名称列表

返回找到的路径，如果未找到返回 nil"
  (let ((names (if (listp name) name (list name))))
    (catch 'found
      (dolist (n names)
        (let ((path (executable-find n)))
          (when path
            (throw 'found path))))
      nil)))

(defun mcg-detect-external-tools (&optional force)
  "检测所有外部工具

参数:
- FORCE: 如果为 t，强制重新检测（忽略缓存）

返回检测结果 alist"
  (interactive "P")
  (when (or force (null mcg-external-tools-cache))
    (setq mcg-external-tools-cache nil)
    (dolist (tool mcg-required-tools)
      (let* ((name (car tool))
             (executable (cdr tool))
             (path (mcg-find-executable executable)))
        (push (cons name path) mcg-external-tools-cache)))
    (setq mcg-external-tools-cache (nreverse mcg-external-tools-cache)))
  
  (when (called-interactively-p 'any)
    (mcg-display-external-tools))
  
  mcg-external-tools-cache)

(defun mcg-get-tool-path (tool)
  "获取外部工具路径

参数:
- TOOL: 工具符号（如 'git, 'ripgrep）

返回工具路径，如果未找到返回 nil"
  (unless mcg-external-tools-cache
    (mcg-detect-external-tools))
  (cdr (assoc tool mcg-external-tools-cache)))

(defun mcg-tool-available-p (tool)
  "检查外部工具是否可用

参数:
- TOOL: 工具符号

返回 t 如果可用，nil 否则"
  (not (null (mcg-get-tool-path tool))))

(defun mcg-display-external-tools ()
  "显示外部工具检测结果"
  (interactive)
  (unless mcg-external-tools-cache
    (mcg-detect-external-tools))
  
  (let ((buffer (get-buffer-create "*External Tools*")))
    (with-current-buffer buffer
      (erase-buffer)
      (insert "外部工具检测结果\n")
      (insert "====================\n\n")
      
      ;; 平台信息
      (unless mcg-platform-info
        (mcg-detect-platform))
      (insert (format "平台: %s (%s)\n"
                      mcg-current-platform
                      (plist-get mcg-platform-info :system-type)))
      (insert (format "Shell: %s\n\n"
                      (plist-get mcg-platform-info :shell)))
      
      ;; 工具列表
      (insert "工具状态:\n")
      (insert (make-string 50 ?-))
      (insert "\n")
      
      (let ((available 0)
            (missing 0))
        (dolist (tool mcg-external-tools-cache)
          (let ((name (car tool))
                (path (cdr tool)))
            (if path
                (progn
                  (setq available (1+ available))
                  (insert (format "[✓] %-12s %s\n" name path)))
              (setq missing (1+ missing))
              (insert (format "[ ] %-12s 未找到\n" name)))))
        
        (insert (make-string 50 ?-))
        (insert "\n")
        (insert (format "总计: %d 可用, %d 缺失\n" available missing)))
      
      (insert "\n按 'q' 关闭此窗口")
      (goto-char (point-min)))
    (display-buffer buffer)))
#+END_SRC

** Graceful Degradation
#+BEGIN_SRC emacs-lisp
;;; 优雅降级

(defvar mcg-degradation-warnings nil
  "降级警告列表

格式: ((FEATURE . WARNING-MESSAGE) ...)")

(defun mcg-warn-degradation (feature message &optional alternative)
  "记录功能降级警告

参数:
- FEATURE: 功能名称符号
- MESSAGE: 警告消息
- ALTERNATIVE: 可选的替代方案描述"
  (let ((warning (list :feature feature
                       :message message
                       :alternative alternative
                       :time (current-time))))
    (push warning mcg-degradation-warnings)
    (message "Warning: %s - %s%s"
             feature
             message
             (if alternative (format " (Alternative: %s)" alternative) ""))))

(defun mcg-check-feature-availability (feature required-tool &optional alternative)
  "检查功能可用性，如果不可用则记录降级警告

参数:
- FEATURE: 功能名称符号
- REQUIRED-TOOL: 需要的工具符号
- ALTERNATIVE: 替代方案描述

返回 t 如果功能可用，nil 否则"
  (if (mcg-tool-available-p required-tool)
      t
    (mcg-warn-degradation
     feature
     (format "Required tool '%s' not found" required-tool)
     alternative)
    nil))

(defun mcg-display-degradation-warnings ()
  "显示所有降级警告"
  (interactive)
  (if (null mcg-degradation-warnings)
      (message "No degradation warnings recorded")
    (let ((buffer (get-buffer-create "*Degradation Warnings*")))
      (with-current-buffer buffer
        (erase-buffer)
        (insert "功能降级警告\n")
        (insert "====================\n\n")
        
        (dolist (warning (reverse mcg-degradation-warnings))
          (insert (format "功能: %s\n" (plist-get warning :feature)))
          (insert (format "警告: %s\n" (plist-get warning :message)))
          (when (plist-get warning :alternative)
            (insert (format "替代: %s\n" (plist-get warning :alternative))))
          (insert "\n"))
        
        (insert "按 'q' 关闭此窗口")
        (goto-char (point-min)))
      (display-buffer buffer))))

(defun mcg-clear-degradation-warnings ()
  "清除所有降级警告"
  (interactive)
  (setq mcg-degradation-warnings nil)
  (message "Degradation warnings cleared"))
#+END_SRC

** Platform Initialization
#+BEGIN_SRC emacs-lisp
;;; 平台初始化

(defun mcg-initialize-platform ()
  "初始化平台检测和外部工具检测

在 Emacs 启动时调用此函数"
  (mcg-detect-platform)
  (mcg-detect-external-tools)
  
  ;; 检查关键工具
  (unless (mcg-tool-available-p 'git)
    (mcg-warn-degradation 'version-control
                          "Git not found"
                          "Install Git for version control features"))
  
  (unless (mcg-tool-available-p 'ripgrep)
    (mcg-warn-degradation 'fast-search
                          "ripgrep not found"
                          "Install ripgrep for faster search, or use grep"))
  
  ;; 返回平台信息
  mcg-platform-info)

(defun mcg-display-platform-info ()
  "显示平台信息"
  (interactive)
  (unless mcg-platform-info
    (mcg-detect-platform))
  
  (let ((buffer (get-buffer-create "*Platform Info*")))
    (with-current-buffer buffer
      (erase-buffer)
      (insert "平台信息\n")
      (insert "====================\n\n")
      
      (insert (format "平台: %s\n" (plist-get mcg-platform-info :platform)))
      (insert (format "系统类型: %s\n" (plist-get mcg-platform-info :system-type)))
      (insert (format "路径分隔符: %s\n"
                      (if (string= (plist-get mcg-platform-info :path-sep) "\\")
                          "\\\\ (反斜杠)"
                        "/ (正斜杠)")))
      (insert (format "行尾符: %s\n"
                      (if (string= (plist-get mcg-platform-info :line-ending) "\r\n")
                          "CRLF (Windows)"
                        "LF (Unix)")))
      (insert (format "Shell: %s\n" (plist-get mcg-platform-info :shell)))
      (insert (format "主目录: %s\n" (plist-get mcg-platform-info :home)))
      
      (insert "\n按 'q' 关闭此窗口")
      (goto-char (point-min)))
    (display-buffer buffer)))

;; 自动初始化平台检测
(mcg-detect-platform)
#+END_SRC

** Ends
#+BEGIN_SRC emacs-lisp
(provide 'init-loadpath)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; init-loadpath.el ends here
#+END_SRC
