* core-lib.el
:PROPERTIES:
:HEADER-ARGS: :tangle core-lib.el :lexical t
:END:

** Headers
#+BEGIN_SRC emacs-lisp
  ;;; core-lib.el --- Core Library Functions for MCG Emacs -*- lexical-binding: t; -*-

  ;; Filename: core-lib.el
  ;; Description: Core library functions, providing extension management and utility functions
  ;; Author: mcge <mcgeq@outlook.com>
  ;; Copyright (C) 2024-2026, mcge, all rights reserved.
  ;; Create   Date: 2026-01-07
  ;; Version: 3.0
  ;; Keywords: extensions, library, utilities
  ;; Compatibility: GNU Emacs 29.0+

  ;;; Commentary:
  ;;
  ;; Core library module for MCG Emacs configuration, responsible for:
  ;; - Extension registry management
  ;; - Extension loading functions
  ;; - Configuration validation system
  ;; - General utility functions
  ;;
  ;; This module depends on core-bootstrap and must be loaded after it.
  ;;

#+END_SRC

** Dependencies
#+BEGIN_SRC emacs-lisp
;;; Dependencies

(require 'cl-lib)
(require 'core-bootstrap)

#+END_SRC

** Extension Registry
#+BEGIN_SRC emacs-lisp
;;; Extension Registry

(defvar mcg-extensions nil
  "Extension registry (simplified version).

Each entry format:
  (PATH :provides (FEATURES...) [:depends (DEPS...)])

Examples:
  (\"core/dash\" :provides (dash))
  (\"core/f.el\" :provides (f) :depends (\"core/dash\" \"core/s.el\"))")

;; Initialize extension registry
(setq mcg-extensions
      '(;; Core libraries
        ("core/dash" :provides (dash))
        ("core/s.el" :provides (s))
        ("core/f.el" :provides (f) :depends ("core/dash" "core/s.el"))
        ("core/compat" :provides (compat))
        ("core/lazy-load" :provides (lazy-load))
        ("core/popup-el" :provides (popup))
        
        ;; Completion
        ("completion/vertico" :provides (vertico))
        ("completion/marginalia" :provides (marginalia))
        ("completion/embark" :provides (embark embark-consult))
        ("completion/consult" :provides (consult))
        ("completion/orderless" :provides (orderless))
        ("completion/pinyinlib" :provides (pinyinlib))
        
        ;; Editor
        ("editor/avy" :provides (avy))
        ("editor/avy-window" :provides (ace-window) :depends ("editor/avy"))
        ("editor/beacon" :provides (beacon))
        ("editor/fingertip" :provides (fingertip))
        ("editor/symbol-overlay" :provides (symbol-overlay))
        ("editor/vundo" :provides (vundo))
        ("editor/wraplish" :provides (wraplish))
        ("editor/ws-butler" :provides (ws-butler))
        
        ;; Git
        ("git/magit" :provides (magit magit-section) :depends ("core/dash" "git/with-editor"))
        ("git/with-editor" :provides (with-editor))
        ("git/llama" :provides (llama))
        ("git/jujutsu" :provides (jujutsu))
        
        ;; Input method
        ("input/emacs-rime" :provides (rime) :depends ("input/posframe"))
        ("input/posframe" :provides (posframe))
        
        ;; LSP
        ("lsp/lsp-bridge" :provides (lsp-bridge acm) :depends ("lsp/markdown-mode"))
        ("lsp/rust-mode" :provides (rust-mode rust-ts-mode))
        ("lsp/lua-mode" :provides (lua-mode lua-ts-mode))
        ("lsp/web-mode" :provides (web-mode))
        ("lsp/markdown-mode" :provides (markdown-mode))
        ("lsp/treesit-auto" :provides (treesit-auto))
        ("lsp/modern-cpp-font-lock" :provides (modern-cpp-font-lock))
        ("lsp/multiple-cursors" :provides (multiple-cursors))
        ("lsp/zig" :provides (zig-mode zig-ts-mode))
        ("lsp/clojure/cider" :provides (cider))
        ("lsp/clojure/clojure-mode" :provides (clojure-mode clojure-ts-mode))
        
        ;; Org
        ("org/org-modern" :provides (org-modern))
        ("org/org-download" :provides (org-download))
        ("org/org-appear" :provides (org-appear))
        ("org/org-numbering" :provides (org-numbering))
        ("org/org-superstar-mode" :provides (org-superstar))
        ("org/visual-fill-column" :provides (visual-fill-column))
        ("org/mixed-pitch" :provides (mixed-pitch))
        ("org/ox-hugo" :provides (ox-hugo) :depends ("org/tomelr"))
        ("org/tomelr" :provides (tomelr))
        ("org/easy-hugo" :provides (easy-hugo))
        ("org/emacs-async" :provides (async))
        ("org/emacs-request" :provides (request))
        ("org/ht" :provides (ht))
        ("org/cal-china-x" :provides (cal-china-x))
        
        ;; Search
        ("search/blink-search" :provides (blink-search))
        ("search/color-rg" :provides (color-rg))
        ("search/consult-todo" :provides (consult-todo) :depends ("search/hl-todo"))
        ("search/hl-todo" :provides (hl-todo))
        
        ;; Snippets
        ("snippets/yasnippet" :provides (yasnippet))
        ("snippets/yasnippet-snippet" :provides (yasnippet-snippets))
        
        ;; UI
        ("ui/awesome-tray" :provides (awesome-tray))
        ("ui/shrink-path" :provides (shrink-path) :depends ("core/dash" "core/f.el" "core/s.el"))
        ("ui/themes" :provides (ef-themes))
        
        ;; Documentation
        ("docs/grip-mode" :provides (grip-mode))
        ("docs/markdown-ts-mode" :provides (markdown-ts-mode))
        ("docs/emacs-htmlize" :provides (htmlize))
        ("docs/flymake-vale" :provides (flymake-vale))
        
        ;; Utilities
        ("utils/helpful" :provides (helpful) :depends ("utils/elisp-refs"))
        ("utils/elisp-refs" :provides (elisp-refs))
        ("utils/sort-tab" :provides (sort-tab))
        ("utils/hydra" :provides (hydra))
        ("utils/json-mode" :provides (json-mode) :depends ("utils/json-snatcher"))
        ("utils/json-snatcher" :provides (json-snatcher))
        ("utils/js2-mode" :provides (js2-mode))
        ("utils/highlight-matching-tag" :provides (highlight-matching-tag))
        ("utils/instant-rename-tag" :provides (instant-rename-tag))))

(defvar mcg-loaded-extensions nil
  "List of loaded extensions.")

(defvar mcg-extension-load-errors nil
  "List of extension load errors.
Each entry format: (PATH . ERROR-MESSAGE)")

#+END_SRC

** Extension Path Functions
#+BEGIN_SRC emacs-lisp
;;; Extension Path Functions

(defun mcg-extension-path (name)
  "Get the full path of extension NAME.

Arguments:
- NAME: Extension path, e.g., \"core/dash\"

Returns the full filesystem path of the extension."
  (when (and name (stringp name) mcg-extensions-dir)
    (expand-file-name name mcg-extensions-dir)))

(defun mcg-extension-exists-p (name)
  "Check if extension NAME exists.

Arguments:
- NAME: Extension path, e.g., \"core/dash\"

Returns t if the extension directory exists, nil otherwise."
  (let ((path (mcg-extension-path name)))
    (and path (file-directory-p path))))

(defun mcg-extension-info (name)
  "Get registration info for extension NAME.

Arguments:
- NAME: Extension path, e.g., \"core/dash\"

Returns the extension's plist info, or nil if not registered."
  (when (and name (stringp name))
    (let ((entry (assoc name mcg-extensions)))
      (when entry
        (list :name name
              :path (mcg-extension-path name)
              :provides (plist-get (cdr entry) :provides)
              :depends (plist-get (cdr entry) :depends)
              :exists (mcg-extension-exists-p name)
              :loaded (member name mcg-loaded-extensions))))))

#+END_SRC

** Extension Loading Functions
#+BEGIN_SRC emacs-lisp
;;; Extension Loading Functions

(defun mcg-extension-dependencies (name)
  "Get all dependencies for extension NAME (recursively resolved).

Arguments:
- NAME: Extension path, e.g., \"core/f.el\"

Returns dependency list, ordered for loading (dependencies first)."
  (let ((entry (assoc name mcg-extensions))
        (result nil)
        (visited nil))
    (when entry
      (cl-labels ((resolve-deps (ext-name)
                    (unless (member ext-name visited)
                      (push ext-name visited)
                      (let* ((ext-entry (assoc ext-name mcg-extensions))
                             (deps (plist-get (cdr ext-entry) :depends)))
                        (dolist (dep deps)
                          (resolve-deps dep)
                          (unless (member dep result)
                            (push dep result)))))))
        (resolve-deps name)))
    (nreverse result)))

(defun mcg-load-extension (name)
  "Load extension NAME to load-path.

Arguments:
- NAME: Extension path, e.g., \"core/dash\"

If the extension directory exists, adds it to load-path and returns t.
If the extension directory doesn't exist, logs a warning and returns nil.
This function won't block startup even if extension is missing."
  (let ((path (mcg-extension-path name)))
    (cond
     ;; Already loaded
     ((member name mcg-loaded-extensions)
      (mcg-log "Extension already loaded: %s" name)
      t)
     
     ;; Directory exists
     ((and path (file-directory-p path))
      ;; Load dependencies first
      (let ((deps (mcg-extension-dependencies name)))
        (dolist (dep deps)
          (mcg-load-extension dep)))
      ;; Add to load-path
      (add-to-list 'load-path path)
      (push name mcg-loaded-extensions)
      (mcg-log "Loaded extension: %s" name)
      t)
     
     ;; Directory doesn't exist - warn but don't block startup
     (t
      (let ((error-msg (format "Extension directory missing: %s" name)))
        (push (cons name error-msg) mcg-extension-load-errors)
        (mcg-log "Warning: %s" error-msg)
        (mcg-log "  Run: git submodule update --init site-lisp/extensions/%s" name))
      nil))))

(defun mcg-load-extensions (names)
  "Batch load extension list NAMES.

Arguments:
- NAMES: List of extension paths

Returns the number of successfully loaded extensions."
  (let ((loaded-count 0))
    (dolist (name names)
      (when (mcg-load-extension name)
        (cl-incf loaded-count)))
    loaded-count))

(defun mcg-require-extension (name &optional feature)
  "Load extension NAME and require its feature.

Arguments:
- NAME: Extension path, e.g., \"core/dash\"
- FEATURE: Feature to require, defaults to the first feature provided by the extension

Returns t if successful, nil if failed."
  (when (mcg-load-extension name)
    (let* ((entry (assoc name mcg-extensions))
           (provides (plist-get (cdr entry) :provides))
           (feat (or feature (car provides))))
      (when feat
        (condition-case err
            (progn
              (require feat)
              t)
          (error
           (let ((error-msg (format "Failed to require %s from %s: %s"
                                    feat name (error-message-string err))))
             (push (cons name error-msg) mcg-extension-load-errors)
             (mcg-log "Error: %s" error-msg))
           nil))))))

#+END_SRC

** Extension Query Functions
#+BEGIN_SRC emacs-lisp
;;; Extension Query Functions

(defun mcg-list-all-extensions ()
  "List all registered extensions.

Returns a list of extension paths."
  (mapcar #'car mcg-extensions))

(defun mcg-list-loaded-extensions ()
  "List all loaded extensions.

Returns a list of loaded extension paths."
  mcg-loaded-extensions)

(defun mcg-list-missing-extensions ()
  "List all missing extensions.

Returns a list of extension paths whose directories don't exist."
  (seq-filter (lambda (name)
                (not (mcg-extension-exists-p name)))
              (mcg-list-all-extensions)))

(defun mcg-extension-provides (name)
  "Get features provided by extension NAME.

Arguments:
- NAME: Extension path

Returns a list of feature symbols."
  (let ((entry (assoc name mcg-extensions)))
    (when entry
      (plist-get (cdr entry) :provides))))

(defun mcg-find-extension-by-feature (feature)
  "Find the extension that provides FEATURE.

Arguments:
- FEATURE: Feature symbol

Returns the extension path, or nil if not found."
  (catch 'found
    (dolist (entry mcg-extensions)
      (let ((provides (plist-get (cdr entry) :provides)))
        (when (memq feature provides)
          (throw 'found (car entry)))))
    nil))

#+END_SRC



** Posframe Popup Utility
#+BEGIN_SRC emacs-lisp
;;; Posframe Popup Utility

(defgroup mcg-popup nil
  "Posframe popup utilities."
  :group 'convenience)

(defcustom mcg-popup-width 60
  "Default width of popup."
  :type 'integer
  :group 'mcg-popup)

(defcustom mcg-popup-height 35
  "Default height of popup."
  :type 'integer
  :group 'mcg-popup)

(defvar mcg--popup-current-buffer nil
  "Current popup buffer name.")

(defun mcg--popup-get-border-color ()
  "Get border color from current theme."
  (or (face-foreground 'font-lock-keyword-face nil t)
      (face-foreground 'link nil t)
      "#61AFEF"))

(defun mcg--popup-get-background-color ()
  "Get background color from current theme."
  (or (face-background 'tooltip nil t)
      (face-background 'default nil t)
      "#282C34"))

(defun mcg--popup-get-foreground-color ()
  "Get foreground color from current theme."
  (or (face-foreground 'default nil t)
      "#ABB2BF"))

(defun mcg--popup-scroll-down ()
  "Scroll popup content down."
  (when-let* ((buf (get-buffer mcg--popup-current-buffer))
              (frame (buffer-local-value 'posframe--frame buf)))
    (with-selected-frame frame
      (ignore-errors (scroll-up 3)))))

(defun mcg--popup-scroll-up ()
  "Scroll popup content up."
  (when-let* ((buf (get-buffer mcg--popup-current-buffer))
              (frame (buffer-local-value 'posframe--frame buf)))
    (with-selected-frame frame
      (ignore-errors (scroll-down 3)))))

(defun mcg-popup-show (buffer-name content &optional width height)
  "Show CONTENT in a centered posframe popup.
BUFFER-NAME is the buffer name for the popup.
WIDTH and HEIGHT are optional dimensions.

Keys: j/k scroll, q/ESC exit"
  (require 'posframe)
  
  (setq mcg--popup-current-buffer buffer-name)
  
  (let* ((buf (get-buffer-create buffer-name))
         (hint "j/k scroll | q/ESC exit")
         (w (or width mcg-popup-width))
         (h (or height mcg-popup-height))
         (padding (make-string (/ (- w (string-width hint)) 2) ?\s))
         (border-color (mcg--popup-get-border-color))
         (bg-color (mcg--popup-get-background-color))
         (fg-color (mcg--popup-get-foreground-color)))
    
    (with-current-buffer buf
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert content))
      (setq-local buffer-read-only t)
      (setq-local cursor-type nil)
      (setq-local header-line-format
                  (propertize (concat padding hint)
                              'face `(:foreground ,border-color :weight bold)))
      (goto-char (point-min)))
    
    (posframe-show buf
                   :position (point)
                   :poshandler #'posframe-poshandler-frame-center
                   :internal-border-width 2
                   :internal-border-color border-color
                   :background-color bg-color
                   :foreground-color fg-color
                   :width w
                   :height h
                   :respect-header-line t
                   :accept-focus nil)
    
    (unwind-protect
        (catch 'exit-popup
          (while t
            (let ((key (read-key)))
              (cond
               ((memq key '(?q 27))
                (throw 'exit-popup nil))
               ((memq key '(?j ?n 14))
                (mcg--popup-scroll-down))
               ((equal key 'down)
                (mcg--popup-scroll-down))
               ((memq key '(?k ?p 16))
                (mcg--popup-scroll-up))
               ((equal key 'up)
                (mcg--popup-scroll-up))
               (t nil)))))
      (posframe-hide buffer-name))))

#+END_SRC

** Configuration Validation System
#+BEGIN_SRC emacs-lisp
;;; Configuration Validation System

(defvar mcg-doctor-issues nil
  "List of issues found during diagnosis.
Each entry format: (:type TYPE :message MSG :fix FIX)")

(defun mcg-verify-core-directories ()
  "Verify that core directories exist.

Returns a list of issues."
  (let ((issues nil)
        (dirs `((,mcg-emacs-dir . "Emacs configuration root directory")
                (,mcg-config-dir . "Configuration directory")
                (,mcg-core-dir . "Core modules directory")
                (,mcg-modules-dir . "Modules directory")
                (,mcg-extensions-dir . "Extensions directory"))))
    (dolist (dir-info dirs)
      (let ((dir (car dir-info))
            (desc (cdr dir-info)))
        (unless (and dir (file-directory-p dir))
          (push (list :type 'missing-directory
                      :message (format "%s does not exist: %s" desc (or dir "not set"))
                      :fix (format "Create directory or check mcg-init-paths configuration"))
                issues))))
    issues))

(defun mcg-verify-extensions ()
  "Verify that extensions exist.

Returns a list of issues."
  (let ((issues nil)
        (missing (mcg-list-missing-extensions)))
    (dolist (name missing)
      (push (list :type 'missing-extension
                  :message (format "Extension missing: %s" name)
                  :fix (format "git submodule update --init site-lisp/extensions/%s" name))
            issues))
    issues))

(defun mcg-verify-module-deps (module-name deps)
  "Verify that module MODULE-NAME's dependencies DEPS are satisfied.

Arguments:
- MODULE-NAME: Module name
- DEPS: Dependency list, each element is (category . module)

Returns a list of issues."
  (let ((issues nil))
    (dolist (dep deps)
      (let* ((category (car dep))
             (module (cdr dep))
             ;; Check if dependency module file exists
             (module-file (expand-file-name
                           (format "%s/+%s.el" category module)
                           mcg-modules-dir)))
        (unless (file-exists-p module-file)
          (push (list :type 'missing-dependency
                      :message (format "Module %s depends on %s/%s, but that module doesn't exist"
                                       module-name category module)
                      :fix (format "Create module file: modules/%s/+%s.org" category module))
                issues))))
    issues))

(defun mcg-verify-load-errors ()
  "Check for extension load errors.

Returns a list of issues."
  (let ((issues nil))
    (dolist (err mcg-extension-load-errors)
      (push (list :type 'load-error
                  :message (cdr err)
                  :fix "Check extension directory or run git submodule update")
            issues))
    issues))

(defun mcg-doctor ()
  "Perform complete configuration diagnosis.

Interactive command that displays all found issues and fix suggestions."
  (interactive)
  (setq mcg-doctor-issues nil)
  
  ;; Collect all issues
  (setq mcg-doctor-issues
        (append (mcg-verify-core-directories)
                (mcg-verify-extensions)
                (mcg-verify-load-errors)))
  
  ;; Display results
  (if (null mcg-doctor-issues)
      (message "✅ Configuration diagnosis passed, no issues found!")
    (with-current-buffer (get-buffer-create "*MCG Doctor*")
      (erase-buffer)
      (insert "MCG Configuration Diagnosis Report\n")
      (insert "===================================\n\n")
      (insert (format "Found %d issues:\n\n" (length mcg-doctor-issues)))
      
      (let ((issue-num 1))
        (dolist (issue mcg-doctor-issues)
          (let ((type (plist-get issue :type))
                (msg (plist-get issue :message))
                (fix (plist-get issue :fix)))
            (insert (format "%d. [%s] %s\n" issue-num type msg))
            (insert (format "   Fix suggestion: %s\n\n" fix))
            (cl-incf issue-num))))
      
      (goto-char (point-min))
      (display-buffer (current-buffer))))
  
  mcg-doctor-issues)

(defun mcg-doctor-check-all-deps ()
  "Check all module dependencies.

Returns a list of issues."
  (let ((issues nil))
    ;; This can only fully check after core-modules is loaded
    ;; Currently only checks extension dependencies
    (dolist (entry mcg-extensions)
      (let* ((name (car entry))
             (deps (plist-get (cdr entry) :depends)))
        (dolist (dep deps)
          (unless (mcg-extension-exists-p dep)
            (push (list :type 'extension-dependency
                        :message (format "Extension %s depends on %s, but %s doesn't exist"
                                         name dep dep)
                        :fix (format "git submodule update --init site-lisp/extensions/%s" dep))
                  issues)))))
    issues))

#+END_SRC

** Interactive Commands
#+BEGIN_SRC emacs-lisp
;;; Interactive Commands

(defun mcg/extension-info (name)
  "Display detailed info for extension NAME.

When called interactively, prompts for extension name."
  (interactive
   (list (completing-read "Extension: " (mcg-list-all-extensions) nil t)))
  (let ((info (mcg-extension-info name)))
    (if info
        (message "Extension: %s\n  Path: %s\n  Provides: %s\n  Depends: %s\n  Exists: %s\n  Loaded: %s"
                 (plist-get info :name)
                 (plist-get info :path)
                 (plist-get info :provides)
                 (or (plist-get info :depends) "none")
                 (if (plist-get info :exists) "yes" "NO")
                 (if (plist-get info :loaded) "yes" "no"))
      (message "Extension not found: %s" name))))

(defun mcg/list-extensions ()
  "Display status of all extensions."
  (interactive)
  (with-current-buffer (get-buffer-create "*MCG Extensions*")
    (erase-buffer)
    (insert "MCG Extension List\n")
    (insert "==================\n\n")
    (insert (format "%-40s %-10s %-10s\n" "Extension" "Exists" "Loaded"))
    (insert (make-string 62 ?-))
    (insert "\n")
    
    (dolist (name (mcg-list-all-extensions))
      (let ((exists (mcg-extension-exists-p name))
            (loaded (member name mcg-loaded-extensions)))
        (insert (format "%-40s %-10s %-10s\n"
                        name
                        (if exists "✓" "✗")
                        (if loaded "✓" "-")))))
    
    (goto-char (point-min))
    (display-buffer (current-buffer))))

(defun mcg/list-missing-extensions ()
  "Display all missing extensions."
  (interactive)
  (let ((missing (mcg-list-missing-extensions)))
    (if missing
        (with-current-buffer (get-buffer-create "*MCG Missing Extensions*")
          (erase-buffer)
          (insert "Missing Extensions\n")
          (insert "==================\n\n")
          (insert "Run the following commands to install:\n\n")
          (dolist (name missing)
            (insert (format "git submodule update --init site-lisp/extensions/%s\n" name)))
          (goto-char (point-min))
          (display-buffer (current-buffer)))
      (message "All extensions are installed!"))))

#+END_SRC

** Provide
#+BEGIN_SRC emacs-lisp
(provide 'core-lib)
;;; core-lib.el ends here
#+END_SRC
