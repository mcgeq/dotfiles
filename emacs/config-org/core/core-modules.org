* core-modules.el
:PROPERTIES:
:HEADER-ARGS: :tangle core-modules.el :lexical t
:END:

** Headers
#+BEGIN_SRC emacs-lisp
  ;;; core-modules.el --- Module System for MCG Emacs -*- lexical-binding: t; -*-

  ;; Filename: core-modules.el
  ;; Description: Module system core, providing declarative module configuration
  ;; Author: mcge <mcgeq@outlook.com>
  ;; Copyright (C) 2024-2026, mcge, all rights reserved.
  ;; Create   Date: 2026-01-07
  ;; Version: 3.0
  ;; Keywords: modules, configuration, declarative
  ;; Compatibility: GNU Emacs 29.0+

  ;;; Commentary:
  ;;
  ;; Module system for MCG Emacs configuration, responsible for:
  ;; - mcg! macro: Declarative module configuration
  ;; - Module registration and loading
  ;; - Deferred loading support
  ;; - Module dependency management
  ;;
  ;; This module depends on core-bootstrap and core-lib.
  ;;

#+END_SRC

** Dependencies
#+BEGIN_SRC emacs-lisp
;;; Dependencies

(require 'core-bootstrap)
(require 'core-lib)

#+END_SRC

** Module Registry
#+BEGIN_SRC emacs-lisp
;;; Module Registry

(defvar mcg-modules-alist nil
  "List of registered modules.

Format is alist: ((CATEGORY . (MODULE1 MODULE2 ...)) ...)

Example:
  ((:ui . (theme modeline))
   (:editor . (defaults treesit))
   (:lang . (lsp rust python)))")

(defvar mcg-disabled-modules nil
  "List of disabled modules.

Format is alist: ((CATEGORY . (MODULE1 MODULE2 ...)) ...)

Modules disabled using -module syntax are recorded here.")

(defvar mcg-module-load-order nil
  "Module load order record.

List of (CATEGORY . MODULE) recorded in actual load order.")

(defvar mcg-loaded-modules nil
  "List of loaded modules.

List of (CATEGORY . MODULE) cons cells.")

(defvar mcg-module-load-errors nil
  "List of module load errors.

Each entry format: ((CATEGORY . MODULE) . ERROR-MESSAGE)")

(defvar mcg-module-dependencies nil
  "Module dependency table.

Format is alist of (((CATEGORY . MODULE) . ((DEP-CAT . DEP-MOD) ...)) ...).
Declared in module files via mcg-module-depends.")

#+END_SRC

** Deprecated Module Support
#+BEGIN_SRC emacs-lisp
;;; Deprecated Module Support

(defvar mcg-deprecated-modules
  '((:input . :editor)
    (:docs . :writing))
  "Deprecated category mappings for migration.

Format is alist: ((OLD-CATEGORY . NEW-CATEGORY) ...)

When a user references a deprecated category, the system will
warn and suggest the new category name.")

(defvar mcg-renamed-modules
  '(((:input . fingertip) . (:editor . paredit))
    ((:input . wraplish) . (:editor . format))
    ((:docs . markdown) . (:writing . markdown))
    ((:tools . sort-tab) . (:tools . tabs))
    ((:tools . utils) . nil))  ; utils is split into multiple modules
  "Renamed module mappings for migration.

Format is alist: (((OLD-CAT . OLD-MOD) . (NEW-CAT . NEW-MOD)) ...)

When a user references a renamed module, the system will warn
and suggest the new module name. A nil value indicates the module
has been split into multiple modules.")

(defun mcg--warn-deprecated-category (category)
  "Warn about deprecated CATEGORY usage and return new category.

Arguments:
- CATEGORY: The category keyword being used

Returns the new category if deprecated, or the original category."
  (let ((mapping (assq category mcg-deprecated-modules)))
    (if mapping
        (let ((new-category (cdr mapping)))
          (display-warning 'mcg
                           (format "Category '%s' is deprecated. Use '%s' instead."
                                   category new-category)
                           :warning)
          new-category)
      category)))

(defun mcg--warn-deprecated-module (category module)
  "Warn about deprecated MODULE in CATEGORY and return new module info.

Arguments:
- CATEGORY: The category keyword
- MODULE: The module symbol

Returns (NEW-CATEGORY . NEW-MODULE) if renamed, or (CATEGORY . MODULE)."
  (let* ((mod-key (cons category module))
         (mapping (assoc mod-key mcg-renamed-modules)))
    (if mapping
        (let ((new-mod (cdr mapping)))
          (if new-mod
              (progn
                (display-warning 'mcg
                                 (format "Module '%s/%s' has been renamed to '%s/%s'."
                                         category module
                                         (car new-mod) (cdr new-mod))
                                 :warning)
                new-mod)
            ;; Module was split
            (display-warning 'mcg
                             (format "Module '%s/%s' has been split into multiple modules. See documentation for migration guide."
                                     category module)
                             :warning)
            nil))
      (cons category module))))

(defun mcg--check-deprecated (category module)
  "Check for deprecated category/module and return resolved values.

Arguments:
- CATEGORY: The category keyword
- MODULE: The module symbol

Returns (RESOLVED-CATEGORY . RESOLVED-MODULE) after checking deprecations.
Returns nil if the module was split and cannot be automatically resolved."
  ;; First check category deprecation
  (let ((resolved-category (mcg--warn-deprecated-category category)))
    ;; Then check module deprecation with resolved category
    (mcg--warn-deprecated-module resolved-category module)))

#+END_SRC

** Module Path Functions
#+BEGIN_SRC emacs-lisp
;;; Module Path Functions

(defun mcg-module-path (category module)
  "Get module file path.

Arguments:
- CATEGORY: Module category, e.g., :ui, :editor, :lang
- MODULE: Module name, e.g., theme, defaults, rust

Returns the full file path of the module (.el file)."
  (when (and category module mcg-modules-dir)
    (let ((cat-name (if (keywordp category)
                        (substring (symbol-name category) 1)
                      (symbol-name category)))
          (mod-name (if (symbolp module)
                        (symbol-name module)
                      module)))
      (expand-file-name (format "%s/init-%s.el" cat-name mod-name)
                        mcg-modules-dir))))

(defun mcg-module-org-path (category module)
  "Get module org file path.

Arguments:
- CATEGORY: Module category
- MODULE: Module name

Returns the .org source file path of the module."
  (when (and category module mcg-modules-dir)
    (let ((cat-name (if (keywordp category)
                        (substring (symbol-name category) 1)
                      (symbol-name category)))
          (mod-name (if (symbolp module)
                        (symbol-name module)
                      module)))
      (expand-file-name (format "%s/init-%s.org" cat-name mod-name)
                        mcg-modules-dir))))

(defun mcg-module-exists-p (category module)
  "Check if module file exists.

Arguments:
- CATEGORY: Module category
- MODULE: Module name

Returns t if the module .el file exists."
  (let ((path (mcg-module-path category module)))
    (and path (file-exists-p path))))

#+END_SRC

** Module Registration
#+BEGIN_SRC emacs-lisp
;;; Module Registration

(defun mcg--register-module (category module)
  "Register module to mcg-modules-alist.

Arguments:
- CATEGORY: Module category (keyword)
- MODULE: Module name (symbol)

Internal function, called by mcg! macro.
Checks for deprecated categories/modules and warns if necessary."
  ;; Check for deprecated category/module and get resolved values
  (let* ((resolved (mcg--check-deprecated category module))
         (resolved-category (if resolved (car resolved) category))
         (resolved-module (if resolved (cdr resolved) module)))
    (when resolved  ; Only register if not a split module (which returns nil)
      (let ((entry (assq resolved-category mcg-modules-alist)))
        (if entry
            ;; Category exists, add module (if not already present)
            (unless (memq resolved-module (cdr entry))
              (setcdr entry (append (cdr entry) (list resolved-module))))
          ;; Category doesn't exist, create new entry
          (push (cons resolved-category (list resolved-module)) mcg-modules-alist))))))

(defun mcg--disable-module (category module)
  "Disable module, record to mcg-disabled-modules.

Arguments:
- CATEGORY: Module category (keyword)
- MODULE: Module name (symbol)

Internal function, called by mcg! macro.
Checks for deprecated categories/modules and warns if necessary."
  ;; Check for deprecated category/module and get resolved values
  (let* ((resolved (mcg--check-deprecated category module))
         (resolved-category (if resolved (car resolved) category))
         (resolved-module (if resolved (cdr resolved) module)))
    (when resolved  ; Only disable if not a split module (which returns nil)
      (let ((entry (assq resolved-category mcg-disabled-modules)))
        (if entry
            (unless (memq resolved-module (cdr entry))
              (setcdr entry (append (cdr entry) (list resolved-module))))
          (push (cons resolved-category (list resolved-module)) mcg-disabled-modules))))))

(defun mcg-module-enabled-p (category module)
  "Check if module is enabled.

Arguments:
- CATEGORY: Module category
- MODULE: Module name

Returns t if module is in mcg-modules-alist and not in mcg-disabled-modules."
  (let ((cat-key (if (keywordp category) category
                   (intern (concat ":" (symbol-name category)))))
        (mod-sym (if (symbolp module) module (intern module))))
    (and (let ((entry (assq cat-key mcg-modules-alist)))
           (and entry (memq mod-sym (cdr entry))))
         (not (let ((disabled (assq cat-key mcg-disabled-modules)))
                (and disabled (memq mod-sym (cdr disabled))))))))

(defun mcg-module-disabled-p (category module)
  "Check if module is disabled.

Arguments:
- CATEGORY: Module category
- MODULE: Module name

Returns t if module is in mcg-disabled-modules."
  (let ((cat-key (if (keywordp category) category
                   (intern (concat ":" (symbol-name category)))))
        (mod-sym (if (symbolp module) module (intern module))))
    (let ((disabled (assq cat-key mcg-disabled-modules)))
      (and disabled (memq mod-sym (cdr disabled))))))

#+END_SRC

** mcg! Macro
#+BEGIN_SRC emacs-lisp
;;; mcg! Macro

(defun mcg--parse-modules (args)
  "Parse mcg! macro arguments.

Arguments:
- ARGS: mcg! macro argument list

Returns parsed module list, format:
  ((CATEGORY . ((MODULE . ENABLED) ...)) ...)

Where ENABLED is t for enabled, nil for disabled (-module syntax)."
  (let ((result nil)
        (current-category nil))
    (dolist (arg args)
      (cond
       ;; Category keyword
       ((keywordp arg)
        (setq current-category arg)
        (unless (assq current-category result)
          (push (cons current-category nil) result)))
       
       ;; Disabled module (-module syntax)
       ((and (symbolp arg)
             (string-prefix-p "-" (symbol-name arg)))
        (when current-category
          (let* ((mod-name (substring (symbol-name arg) 1))
                 (mod-sym (intern mod-name))
                 (entry (assq current-category result)))
            (when entry
              (setcdr entry (append (cdr entry)
                                    (list (cons mod-sym nil))))))))
       
       ;; Enabled module
       ((symbolp arg)
        (when current-category
          (let ((entry (assq current-category result)))
            (when entry
              (setcdr entry (append (cdr entry)
                                    (list (cons arg t))))))))))
    (nreverse result)))

(defmacro mcg! (&rest modules)
  "Declare enabled modules.

Usage:
  (mcg! :ui theme modeline
        :editor defaults treesit
        :lang lsp rust -lua)

Syntax:
- :category - Module category (e.g., :ui, :editor, :lang)
- module - Enable module
- -module - Disable module (with - prefix)

This macro parses declarations and registers modules to mcg-modules-alist.
Disabled modules are recorded to mcg-disabled-modules."
  (let ((parsed (mcg--parse-modules modules)))
    `(progn
       ;; Clear previous registration (allow re-declaration)
       (setq mcg-modules-alist nil)
       (setq mcg-disabled-modules nil)
       
       ;; Register modules
       ,@(mapcan
          (lambda (cat-entry)
            (let ((category (car cat-entry))
                  (mods (cdr cat-entry)))
              (mapcar
               (lambda (mod-entry)
                 (let ((module (car mod-entry))
                       (enabled (cdr mod-entry)))
                   (if enabled
                       `(mcg--register-module ',category ',module)
                     `(mcg--disable-module ',category ',module))))
               mods)))
          parsed)
       
       ;; Return registered module list
       mcg-modules-alist)))

#+END_SRC

** Module Loading
#+BEGIN_SRC emacs-lisp
;;; Module Loading

(defun mcg-module-depends (category module &rest deps)
  "Declare module dependencies.

Arguments:
- CATEGORY: Current module category
- MODULE: Current module name
- DEPS: Dependency list, each element is (CATEGORY . MODULE)

Usage (at the beginning of module file):
  (mcg-module-depends :lang 'rust
    '(:lang . lsp)
    '(:editor . treesit))"
  (let* ((cat-key (if (keywordp category) category
                    (intern (concat ":" (symbol-name category)))))
         (mod-sym (if (symbolp module) module (intern module)))
         (mod-key (cons cat-key mod-sym)))
    (setf (alist-get mod-key mcg-module-dependencies nil nil #'equal) deps)
    (mcg-log "Registered dependencies for %s/%s: %s" cat-key mod-sym deps)))

(defun mcg-get-module-deps (category module)
  "Get module's dependency list."
  (let* ((cat-key (if (keywordp category) category
                    (intern (concat ":" (symbol-name category)))))
         (mod-sym (if (symbolp module) module (intern module)))
         (mod-key (cons cat-key mod-sym)))
    (alist-get mod-key mcg-module-dependencies nil nil #'equal)))

(defun mcg-load-module-deps (category module)
  "Load all dependencies of a module.

Returns t if all dependencies loaded successfully."
  (let ((deps (mcg-get-module-deps category module))
        (all-loaded t))
    (dolist (dep deps)
      (let ((dep-cat (car dep))
            (dep-mod (cdr dep)))
        (unless (mcg-module-loaded-p dep-cat dep-mod)
          (mcg-log "Loading dependency: %s/%s for %s/%s"
                   dep-cat dep-mod category module)
          (unless (mcg-load-module dep-cat dep-mod)
            (setq all-loaded nil)))))
    all-loaded))

(defun mcg-load-module (category module)
  "Load specified module.

Arguments:
- CATEGORY: Module category
- MODULE: Module name

Returns t if loaded successfully, nil if failed.
Load failures are recorded but don't block continued execution."
  (let* ((cat-key (if (keywordp category) category
                    (intern (concat ":" (symbol-name category)))))
         (mod-sym (if (symbolp module) module (intern module)))
         (mod-key (cons cat-key mod-sym))
         (path (mcg-module-path cat-key mod-sym))
         (feature-name (intern (format "init-%s" mod-sym))))
    
    ;; Check if already loaded
    (if (member mod-key mcg-loaded-modules)
        (progn
          (mcg-log "Module already loaded: %s/%s" cat-key mod-sym)
          t)
      
      ;; Check if disabled
      (if (mcg-module-disabled-p cat-key mod-sym)
          (progn
            (mcg-log "Module disabled, skipping: %s/%s" cat-key mod-sym)
            nil)
        
        ;; Try to load
        (if (and path (file-exists-p path))
            (condition-case err
                (mcg-profile (format "module:%s/%s" cat-key mod-sym)
                  (load path nil t)
                  (push mod-key mcg-loaded-modules)
                  (push mod-key mcg-module-load-order)
                  ;; Load dependencies (if declared)
                  (mcg-load-module-deps cat-key mod-sym)
                  (mcg-log "Loaded module: %s/%s" cat-key mod-sym)
                  ;; Run hook
                  (run-hooks 'mcg-module-load-hook)
                  t)
              (error
               (let ((error-msg (format "Error loading %s/%s: %s"
                                        cat-key mod-sym
                                        (error-message-string err))))
                 (push (cons mod-key error-msg) mcg-module-load-errors)
                 (mcg-log "Error: %s" error-msg))
               nil))
          
          ;; File doesn't exist
          (let ((error-msg (format "Module file not found: %s/%s (path: %s)"
                                   cat-key mod-sym path)))
            (push (cons mod-key error-msg) mcg-module-load-errors)
            (mcg-log "Warning: %s" error-msg))
          nil)))))

(defun mcg-load-module-safe (category module)
  "Safely load module, catching all errors.

Arguments:
- CATEGORY: Module category
- MODULE: Module name

Same as mcg-load-module, but ensures no errors are thrown."
  (condition-case err
      (mcg-load-module category module)
    (error
     (mcg-log "Critical error loading %s/%s: %s"
              category module (error-message-string err))
     nil)))

(defun mcg-load-module-with-trace (category module)
  "Load MODULE with full error trace.

Arguments:
- CATEGORY: Module category
- MODULE: Module name

This function captures full backtrace on error and stores structured
error information. Unlike `mcg-load-module', this function stores
detailed trace information for debugging purposes.

Returns t if loaded successfully, nil if failed.
Errors are recorded with full backtrace but don't block continued execution."
  (let* ((cat-key (if (keywordp category) category
                    (intern (concat ":" (symbol-name category)))))
         (mod-sym (if (symbolp module) module (intern module)))
         (mod-key (cons cat-key mod-sym))
         (path (mcg-module-path cat-key mod-sym)))
    
    ;; Check if already loaded
    (if (member mod-key mcg-loaded-modules)
        (progn
          (mcg-log "Module already loaded: %s/%s" cat-key mod-sym)
          t)
      
      ;; Check if disabled
      (if (mcg-module-disabled-p cat-key mod-sym)
          (progn
            (mcg-log "Module disabled, skipping: %s/%s" cat-key mod-sym)
            nil)
        
        ;; Try to load with trace capture
        (if (and path (file-exists-p path))
            (condition-case-unless-debug err
                (mcg-profile (format "module:%s/%s" cat-key mod-sym)
                  (load path nil t)
                  (push mod-key mcg-loaded-modules)
                  (push mod-key mcg-module-load-order)
                  ;; Load dependencies (if declared)
                  (mcg-load-module-deps cat-key mod-sym)
                  (mcg-log "Loaded module: %s/%s" cat-key mod-sym)
                  ;; Run hook
                  (run-hooks 'mcg-module-load-hook)
                  t)
              (error
               ;; Capture full backtrace
               (let* ((trace (with-output-to-string (backtrace)))
                      (error-info (list :category cat-key
                                        :module mod-sym
                                        :error (error-message-string err)
                                        :error-data err
                                        :trace trace
                                        :path path
                                        :timestamp (current-time))))
                 ;; Store structured error information
                 (push (cons mod-key error-info) mcg-module-load-errors)
                 (mcg-log "Error loading %s/%s: %s" cat-key mod-sym
                          (error-message-string err))
                 (mcg-log "Trace:\n%s" trace))
               nil))
          
          ;; File doesn't exist
          (let ((error-info (list :category cat-key
                                  :module mod-sym
                                  :error (format "Module file not found: %s" path)
                                  :error-data nil
                                  :trace nil
                                  :path path
                                  :timestamp (current-time))))
            (push (cons mod-key error-info) mcg-module-load-errors)
            (mcg-log "Warning: Module file not found: %s/%s (path: %s)"
                     cat-key mod-sym path))
          nil)))))

(defun mcg-get-module-error-trace (category module)
  "Get the error trace for a failed module load.

Arguments:
- CATEGORY: Module category
- MODULE: Module name

Returns the error info plist if the module failed to load, nil otherwise."
  (let* ((cat-key (if (keywordp category) category
                    (intern (concat ":" (symbol-name category)))))
         (mod-sym (if (symbolp module) module (intern module)))
         (mod-key (cons cat-key mod-sym))
         (error-entry (assoc mod-key mcg-module-load-errors)))
    (when error-entry
      (cdr error-entry))))

(defun mcg-format-module-error (error-info)
  "Format ERROR-INFO plist into a human-readable string.

Arguments:
- ERROR-INFO: Error info plist from mcg-module-load-errors

Returns a formatted string with error details."
  (if (listp error-info)
      (if (plist-get error-info :category)
          ;; New structured format
          (let ((category (plist-get error-info :category))
                (module (plist-get error-info :module))
                (error-msg (plist-get error-info :error))
                (trace (plist-get error-info :trace))
                (path (plist-get error-info :path)))
            (concat
             (format "Module: %s/%s\n" category module)
             (format "Path: %s\n" (or path "N/A"))
             (format "Error: %s\n" error-msg)
             (when trace
               (format "\nBacktrace:\n%s" trace))))
        ;; Old string format (for backward compatibility)
        (format "%s" error-info))
    (format "%s" error-info)))

(defun mcg-load-modules-by-category (category)
  "Load all enabled modules in a category.

Arguments:
- CATEGORY: Module category

Returns the number of successfully loaded modules."
  (let ((cat-key (if (keywordp category) category
                   (intern (concat ":" (symbol-name category)))))
        (loaded-count 0))
    (let ((entry (assq cat-key mcg-modules-alist)))
      (when entry
        (dolist (module (cdr entry))
          (when (mcg-load-module cat-key module)
            (cl-incf loaded-count)))))
    loaded-count))

(defun mcg-load-all-modules ()
  "Load all registered modules.

Loads in the order of mcg-modules-alist.
Returns the total number of successfully loaded modules."
  (let ((total-loaded 0))
    (dolist (entry mcg-modules-alist)
      (let ((category (car entry)))
        (cl-incf total-loaded (mcg-load-modules-by-category category))))
    total-loaded))

#+END_SRC


** Deferred Loading
#+BEGIN_SRC emacs-lisp
;;; Deferred Loading

(defvar mcg-deferred-modules nil
  "List of deferred modules.

Format is alist of ((CATEGORY . MODULE) . TRIGGER).
TRIGGER can be:
- hook name (symbol)
- auto-mode-alist entry
- file extension string")

(defvar mcg-module-triggers
  '(;; Language module triggers
    ((:lang . rust) . ("\\.rs\\'" . rust-mode))
    ((:lang . python) . ("\\.py\\'" . python-mode))
    ((:lang . typescript) . ("\\.tsx?\\'" . typescript-mode))
    ((:lang . web) . ("\\.vue\\'" . web-mode))
    ((:lang . lua) . ("\\.lua\\'" . lua-mode))
    ((:lang . zig) . ("\\.zig\\'" . zig-mode))
    ((:lang . cpp) . ("\\.\\(cpp\\|cc\\|cxx\\|h\\|hpp\\)\\'" . c++-mode))
    ((:lang . clojure) . ("\\.clj[sc]?\\'" . clojure-mode))
    ;; Writing module triggers
    ((:writing . markdown) . ("\\.md\\'" . markdown-ts-mode))
    ((:writing . vale) . ("\\.md\\'" . markdown-ts-mode)))
  "Module trigger mapping.

Format is alist of ((CATEGORY . MODULE) . (PATTERN . MODE)).
When opening a file matching PATTERN, automatically load the corresponding module.")

(defun mcg--find-mode-extension-path (mode)
  "Automatically find extension path for MODE.

Prioritizes cache, scans directory on cache miss."
  (let ((mode-file (concat (symbol-name mode) ".el")))
    ;; Check cache first
    (or (and (boundp 'mcg-extension-cache)
             (mcg-cache-lookup mode-file))
        ;; Cache miss, scan directory
        (catch 'found
          (dolist (category-dir (directory-files mcg-extensions-dir t "^[^.]"))
            (when (file-directory-p category-dir)
              (dolist (ext-dir (directory-files category-dir t "^[^.]"))
                (when (and (file-directory-p ext-dir)
                           (file-exists-p (expand-file-name mode-file ext-dir)))
                  ;; Store in cache
                  (when (fboundp 'mcg-cache-store)
                    (mcg-cache-store mode-file ext-dir))
                  (throw 'found ext-dir)))
              ;; Check second-level subdirectories
              (dolist (sub-dir (directory-files category-dir t "^[^.]"))
                (when (file-directory-p sub-dir)
                  (dolist (ext-dir (directory-files sub-dir t "^[^.]"))
                    (when (and (file-directory-p ext-dir)
                               (file-exists-p (expand-file-name mode-file ext-dir)))
                      (when (fboundp 'mcg-cache-store)
                        (mcg-cache-store mode-file ext-dir))
                      (throw 'found ext-dir)))))))
          nil))))

(defun mcg--setup-mode-autoload (mode)
  "Set up autoload for MODE.

Arguments:
- MODE: mode function symbol

Automatically scans extension directory to find extension path for MODE."
  (unless (fboundp mode)
    (let ((full-path (mcg--find-mode-extension-path mode)))
      (when (and full-path (file-directory-p full-path))
        ;; Add to load-path
        (add-to-list 'load-path full-path)
        ;; Set up autoload
        (autoload mode (symbol-name mode) nil t)))))

(defun mcg-defer-module (category module &optional trigger)
  "Defer loading of module.

Arguments:
- CATEGORY: Module category
- MODULE: Module name
- TRIGGER: Trigger condition (optional)

If TRIGGER is not specified, uses default trigger from mcg-module-triggers."
  (let* ((cat-key (if (keywordp category) category
                    (intern (concat ":" (symbol-name category)))))
         (mod-sym (if (symbolp module) module (intern module)))
         (mod-key (cons cat-key mod-sym))
         (trig (or trigger
                   (cdr (assoc mod-key mcg-module-triggers)))))
    
    ;; Record deferred loading
    (push (cons mod-key trig) mcg-deferred-modules)
    
    ;; Set up trigger
    (when trig
      (cond
       ;; auto-mode-alist trigger
       ((and (consp trig) (stringp (car trig)))
        (let ((pattern (car trig))
              (mode (cdr trig)))
          ;; Set up autoload first to ensure mode function exists
          (mcg--setup-mode-autoload mode)
          ;; Add auto-mode-alist entry
          (add-to-list 'auto-mode-alist (cons pattern mode))
          ;; Set up mode hook to load module configuration
          (let ((hook-name (intern (format "%s-hook" mode))))
            (add-hook hook-name
                      (lambda ()
                        (mcg--trigger-deferred-load cat-key mod-sym))
                      nil t))))
       
       ;; hook trigger
       ((symbolp trig)
        (add-hook trig
                  (lambda ()
                    (mcg--trigger-deferred-load cat-key mod-sym))))))
    
    (mcg-log "Deferred module: %s/%s (trigger: %s)" cat-key mod-sym trig)))

(defun mcg--trigger-deferred-load (category module)
  "Trigger deferred loading.

Arguments:
- CATEGORY: Module category
- MODULE: Module name

Internal function, called by triggers."
  (let ((mod-key (cons category module)))
    ;; Only load once
    (unless (member mod-key mcg-loaded-modules)
      (mcg-log "Triggering deferred load: %s/%s" category module)
      (mcg-load-module category module))))

(defun mcg-setup-deferred-loading ()
  "Set up deferred loading for all language modules.

Iterates through mcg-module-triggers, setting up deferred loading for all registered language modules."
  (dolist (trigger-entry mcg-module-triggers)
    (let* ((mod-key (car trigger-entry))
           (category (car mod-key))
           (module (cdr mod-key)))
      ;; Only set up deferred loading for registered modules
      (when (mcg-module-enabled-p category module)
        (mcg-defer-module category module)))))

#+END_SRC

** Idle Loading
#+BEGIN_SRC emacs-lisp
;;; Idle Loading

(defvar mcg-idle-load-modules nil
  "Modules to load during idle time.

Format: ((CATEGORY . MODULE) ...)

These modules are loaded after Emacs becomes idle for
`mcg-idle-load-delay' seconds. This is useful for modules
that are not immediately needed at startup but should be
available soon after.")

(defvar mcg-idle-load-delay 2
  "Seconds to wait before idle loading.

After Emacs startup completes and becomes idle for this many
seconds, modules in `mcg-idle-load-modules' will be loaded.")

(defvar mcg-idle-load-timer nil
  "Timer for idle loading.

Internal variable to track the idle timer.")

(defvar mcg-idle-loaded-modules nil
  "List of modules loaded via idle loading.

Format: ((CATEGORY . MODULE) ...)

Tracks which modules have been loaded through the idle loading
mechanism to avoid duplicate loading.")

(defun mcg--idle-load-next-module ()
  "Load the next module from idle load queue.

Internal function called by the idle timer.
Loads one module at a time to avoid blocking."
  (when mcg-idle-load-modules
    (let* ((mod-key (car mcg-idle-load-modules))
           (category (car mod-key))
           (module (cdr mod-key)))
      ;; Remove from queue
      (setq mcg-idle-load-modules (cdr mcg-idle-load-modules))
      ;; Load if not already loaded
      (unless (member mod-key mcg-loaded-modules)
        (mcg-log "Idle loading: %s/%s" category module)
        (when (mcg-load-module category module)
          (push mod-key mcg-idle-loaded-modules)))
      ;; Schedule next module if queue not empty
      (when mcg-idle-load-modules
        (run-with-idle-timer 0.1 nil #'mcg--idle-load-next-module)))))

(defun mcg-setup-idle-loading ()
  "Setup idle loading for specified modules.

Schedules modules in `mcg-idle-load-modules' to be loaded
after Emacs becomes idle for `mcg-idle-load-delay' seconds.

This function should be called after module declaration (mcg!)
and after immediate module loading is complete.

Usage example:
  ;; In init.org, after mcg! declaration:
  (mcg-add-idle-load-category :completion)
  (mcg-add-idle-load-category :enhance)
  (mcg-setup-idle-loading)"
  (when mcg-idle-load-modules
    ;; Cancel any existing timer
    (when (timerp mcg-idle-load-timer)
      (cancel-timer mcg-idle-load-timer))
    ;; Setup new idle timer
    (setq mcg-idle-load-timer
          (run-with-idle-timer mcg-idle-load-delay nil
                               #'mcg--idle-load-next-module))
    (mcg-log "Idle loading scheduled: %d modules after %d seconds"
             (length mcg-idle-load-modules) mcg-idle-load-delay)))

(defun mcg-add-idle-load-module (category module)
  "Add a module to the idle load queue.

Arguments:
- CATEGORY: Module category (keyword)
- MODULE: Module name (symbol)

The module will be loaded when Emacs becomes idle.

Usage examples:
  ;; Add a single module to idle loading
  (mcg-add-idle-load-module :completion 'vertico)
  
  ;; Add multiple modules
  (mcg-add-idle-load-module :enhance 'which-key)
  (mcg-add-idle-load-module :enhance 'helpful)"
  (let* ((cat-key (if (keywordp category) category
                    (intern (concat ":" (symbol-name category)))))
         (mod-sym (if (symbolp module) module (intern module)))
         (mod-key (cons cat-key mod-sym)))
    ;; Only add if enabled and not already loaded
    (when (and (mcg-module-enabled-p cat-key mod-sym)
               (not (member mod-key mcg-loaded-modules))
               (not (member mod-key mcg-idle-load-modules)))
      (push mod-key mcg-idle-load-modules)
      (mcg-log "Added to idle load queue: %s/%s" cat-key mod-sym))))

(defun mcg-add-idle-load-category (category)
  "Add all modules in a category to the idle load queue.

Arguments:
- CATEGORY: Module category (keyword)

All enabled modules in the category will be added to the idle load queue.

Usage examples:
  ;; Add all completion modules to idle loading
  (mcg-add-idle-load-category :completion)
  
  ;; Add all enhance modules to idle loading
  (mcg-add-idle-load-category :enhance)"
  (let ((cat-key (if (keywordp category) category
                   (intern (concat ":" (symbol-name category))))))
    (let ((entry (assq cat-key mcg-modules-alist)))
      (when entry
        (dolist (module (cdr entry))
          (mcg-add-idle-load-module cat-key module))))))

(defun mcg-list-idle-load-modules ()
  "List modules scheduled for idle loading.

Returns a list of (CATEGORY . MODULE)."
  mcg-idle-load-modules)

(defun mcg-list-idle-loaded-modules ()
  "List modules that have been loaded via idle loading.

Returns a list of (CATEGORY . MODULE)."
  mcg-idle-loaded-modules)

#+END_SRC

** mcg-after! Macro
#+BEGIN_SRC emacs-lisp
;;; mcg-after! Macro

(defmacro mcg-after! (feature &rest body)
  "Execute BODY after FEATURE is loaded.

Arguments:
- FEATURE: feature symbol or module identifier (CATEGORY . MODULE)
- BODY: Code to execute

Usage:
  (mcg-after! magit
    (setq magit-display-buffer-function ...))

  (mcg-after! (:lang . rust)
    (setq rust-format-on-save t))"
  (declare (indent 1))
  (if (and (consp feature) (keywordp (car feature)))
      ;; Module identifier
      (let ((category (car feature))
            (module (cdr feature)))
        `(if (member (cons ',category ',module) mcg-loaded-modules)
             (progn ,@body)
           (add-hook 'mcg-module-load-hook
                     (lambda ()
                       (when (member (cons ',category ',module) mcg-loaded-modules)
                         ,@body)))))
    ;; feature symbol
    `(with-eval-after-load ',feature
       ,@body)))

(defvar mcg-module-load-hook nil
  "Hook run after module loading.

This hook runs after each module is loaded.")

#+END_SRC

** Module Query Functions
#+BEGIN_SRC emacs-lisp
;;; Module Query Functions

(defun mcg-list-enabled-modules ()
  "List all enabled modules.

Returns a list of (CATEGORY . MODULE)."
  (let ((result nil))
    (dolist (entry mcg-modules-alist)
      (let ((category (car entry)))
        (dolist (module (cdr entry))
          (unless (mcg-module-disabled-p category module)
            (push (cons category module) result)))))
    (nreverse result)))

(defun mcg-list-loaded-modules ()
  "List all loaded modules.

Returns a list of (CATEGORY . MODULE)."
  mcg-loaded-modules)

(defun mcg-list-deferred-modules ()
  "List all deferred modules.

Returns an alist of ((CATEGORY . MODULE) . TRIGGER)."
  mcg-deferred-modules)

(defun mcg-module-loaded-p (category module)
  "Check if module is loaded.

Arguments:
- CATEGORY: Module category
- MODULE: Module name

Returns t if module is loaded."
  (let ((cat-key (if (keywordp category) category
                   (intern (concat ":" (symbol-name category)))))
        (mod-sym (if (symbolp module) module (intern module))))
    (member (cons cat-key mod-sym) mcg-loaded-modules)))

(defun mcg-get-module-errors ()
  "Get all module load errors.

Returns an alist of ((CATEGORY . MODULE) . ERROR-MESSAGE)."
  mcg-module-load-errors)

#+END_SRC

** Interactive Commands
#+BEGIN_SRC emacs-lisp
;;; Interactive Commands

(defvar mcg-modules-popup-buffer "*MCG Modules*"
  "Buffer name for modules popup.")

(defun mcg--modules-popup-scroll-down ()
  "Scroll popup content down."
  (when-let* ((buf (get-buffer mcg-modules-popup-buffer))
              (frame (buffer-local-value 'posframe--frame buf)))
    (with-selected-frame frame
      (ignore-errors (scroll-up 3)))))

(defun mcg--modules-popup-scroll-up ()
  "Scroll popup content up."
  (when-let* ((buf (get-buffer mcg-modules-popup-buffer))
              (frame (buffer-local-value 'posframe--frame buf)))
    (with-selected-frame frame
      (ignore-errors (scroll-down 3)))))

(defun mcg-list-modules ()
  "Display all enabled modules and their status.

Uses posframe to display module list popup centered on screen.
Keys: j/k scroll, q/ESC exit"
  (interactive)
  (require 'posframe)
  
  (let* ((buf (get-buffer-create mcg-modules-popup-buffer))
         (content (mcg--generate-modules-content))
         (hint "j/k scroll | q/ESC exit")
         (padding (make-string (/ (- 60 (string-width hint)) 2) ?\s)))
    
    (with-current-buffer buf
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert content))
      (setq-local buffer-read-only t)
      (setq-local cursor-type nil)
      (setq-local header-line-format
                  (propertize (concat padding hint)
                              'face '(:foreground "#61AFEF" :weight bold)))
      (goto-char (point-min)))
    
    ;; Use posframe to display centered popup
    (posframe-show buf
                   :position (point)
                   :poshandler #'posframe-poshandler-frame-center
                   :internal-border-width 2
                   :internal-border-color "#61AFEF"
                   :background-color "#282C34"
                   :foreground-color "#ABB2BF"
                   :width 62
                   :height 30
                   :respect-header-line t
                   :accept-focus nil)
    
    ;; Use read-key loop to handle keys
    (unwind-protect
        (catch 'exit-popup
          (while t
            (let ((key (read-key)))
              (cond
               ;; Exit
               ((memq key '(?q 27))  ; q or ESC
                (throw 'exit-popup nil))
               ;; Scroll down
               ((memq key '(?j ?n 14))  ; j, n, C-n
                (mcg--modules-popup-scroll-down))
               ((equal key 'down)
                (mcg--modules-popup-scroll-down))
               ;; Scroll up
               ((memq key '(?k ?p 16))  ; k, p, C-p
                (mcg--modules-popup-scroll-up))
               ((equal key 'up)
                (mcg--modules-popup-scroll-up))
               ;; Ignore other keys
               (t nil)))))
      ;; Cleanup
      (posframe-hide mcg-modules-popup-buffer))))

(defun mcg--generate-modules-content ()
  "Generate module list content string."
  (with-temp-buffer
    (insert "╔══════════════════════════════════════════════════════════╗\n")
    (insert "║                    MCG Module List                       ║\n")
    (insert "╚══════════════════════════════════════════════════════════╝\n\n")
    
    ;; Statistics
    (let ((enabled (length (mcg-list-enabled-modules)))
          (loaded (length mcg-loaded-modules))
          (deferred (length mcg-deferred-modules))
          (idle-pending (length mcg-idle-load-modules))
          (idle-loaded (length mcg-idle-loaded-modules))
          (errors (length mcg-module-load-errors)))
      (insert (format "  Enabled: %d | Loaded: %d | Deferred: %d | Idle: %d/%d | Errors: %d\n\n"
                      enabled loaded deferred idle-loaded idle-pending errors)))
    
    ;; Display modules by category
    (insert (format "  %-12s %-20s %-10s %-6s\n"
                    "Category" "Module" "Status" "File"))
    (insert "  ")
    (insert (make-string 52 ?─))
    (insert "\n")
    
    (dolist (entry mcg-modules-alist)
      (let ((category (car entry)))
        (dolist (module (cdr entry))
          (let* ((mod-key (cons category module))
                 (loaded (member mod-key mcg-loaded-modules))
                 (deferred (assoc mod-key mcg-deferred-modules))
                 (idle-pending (member mod-key mcg-idle-load-modules))
                 (idle-loaded (member mod-key mcg-idle-loaded-modules))
                 (disabled (mcg-module-disabled-p category module))
                 (exists (mcg-module-exists-p category module))
                 (status (cond
                          (disabled "Disabled")
                          (loaded (if idle-loaded "Idle-Loaded" "Loaded"))
                          (idle-pending "Idle-Pend")
                          (deferred "Deferred")
                          (t "Pending"))))
            (insert (format "  %-12s %-20s %-10s %-6s\n"
                            (substring (symbol-name category) 1)
                            module
                            status
                            (if exists "✓" "✗")))))))
    
    ;; Display errors
    (when mcg-module-load-errors
      (insert "\n  Load Errors:\n  ")
      (insert (make-string 40 ?─))
      (insert "\n")
      (dolist (err mcg-module-load-errors)
        (insert (format "  • %s/%s: %s\n"
                        (caar err) (cdar err) (cdr err)))))
    
    (buffer-string)))

(defun mcg--unload-module-keybindings (source)
  "Remove keybindings registered by SOURCE from the registry.

Arguments:
- SOURCE: The source module name (string)

Returns the number of keybindings removed."
  (when (boundp 'mcg-keybinding-registry)
    (let ((count 0)
          (to-remove nil))
      ;; Find all keybindings from this source
      (dolist (entry mcg-keybinding-registry)
        (when (equal (cddr entry) source)
          (push (car entry) to-remove)
          (cl-incf count)))
      ;; Remove them from registry
      (dolist (key to-remove)
        (setq mcg-keybinding-registry
              (assoc-delete-all key mcg-keybinding-registry)))
      count)))

(defun mcg--module-feature-name (category module)
  "Get the feature name for a module.

Arguments:
- CATEGORY: Module category (keyword)
- MODULE: Module name (symbol)

Returns the feature symbol (e.g., init-theme)."
  (let ((mod-name (if (symbolp module)
                      (symbol-name module)
                    module)))
    (intern (format "init-%s" mod-name))))

(defun mcg/reload-module (category module)
  "Reload specified module.

This function:
1. Unloads the module's feature if loaded
2. Removes keybindings registered by this module from the registry
3. Removes the module from the loaded modules list
4. Reloads the module fresh

When called interactively, prompts for module selection."
  (interactive
   (let* ((modules (mcg-list-enabled-modules))
          (choices (mapcar (lambda (m)
                             (format "%s/%s"
                                     (substring (symbol-name (car m)) 1)
                                     (cdr m)))
                           modules))
          (choice (completing-read "Reload module: " choices nil t))
          (parts (split-string choice "/")))
     (list (intern (concat ":" (car parts)))
           (intern (cadr parts)))))
  
  (let* ((cat-key (if (keywordp category) category
                    (intern (concat ":" (symbol-name category)))))
         (mod-sym (if (symbolp module) module (intern module)))
         (mod-key (cons cat-key mod-sym))
         (feature-name (mcg--module-feature-name cat-key mod-sym))
         (source-name (format "init-%s" mod-sym))
         (keybindings-removed 0))
    
    ;; 1. Unload the feature if it's loaded
    (when (featurep feature-name)
      (condition-case err
          (unload-feature feature-name t)
        (error
         (mcg-log "Warning: Could not unload feature %s: %s"
                  feature-name (error-message-string err)))))
    
    ;; 2. Remove keybindings registered by this module
    (setq keybindings-removed (mcg--unload-module-keybindings source-name))
    (when (> keybindings-removed 0)
      (mcg-log "Removed %d keybindings from %s" keybindings-removed source-name))
    
    ;; 3. Remove from loaded list
    (setq mcg-loaded-modules (delete mod-key mcg-loaded-modules))
    
    ;; 4. Reload the module
    (if (mcg-load-module cat-key mod-sym)
        (progn
          (mcg-log "Successfully reloaded module: %s/%s" cat-key mod-sym)
          (message "✓ Reloaded module: %s/%s (removed %d old keybindings)"
                   cat-key mod-sym keybindings-removed))
      (message "✗ Failed to reload module: %s/%s" cat-key mod-sym))))

(defun mcg/describe-module (category module)
  "Display detailed info for a module.

When called interactively, prompts for module selection."
  (interactive
   (let* ((modules (mcg-list-enabled-modules))
          (choices (mapcar (lambda (m)
                             (format "%s/%s"
                                     (substring (symbol-name (car m)) 1)
                                     (cdr m)))
                           modules))
          (choice (completing-read "Describe module: " choices nil t))
          (parts (split-string choice "/")))
     (list (intern (concat ":" (car parts)))
           (intern (cadr parts)))))
  (let* ((cat-key (if (keywordp category) category
                    (intern (concat ":" (symbol-name category)))))
         (mod-sym (if (symbolp module) module (intern module)))
         (mod-key (cons cat-key mod-sym))
         (path (mcg-module-path cat-key mod-sym))
         (org-path (mcg-module-org-path cat-key mod-sym))
         (loaded (member mod-key mcg-loaded-modules))
         (deferred (assoc mod-key mcg-deferred-modules))
         (disabled (mcg-module-disabled-p cat-key mod-sym))
         (exists (mcg-module-exists-p cat-key mod-sym)))
    (message "Module: %s/%s\n  Path: %s\n  Org: %s\n  Exists: %s\n  Status: %s"
             cat-key mod-sym
             (or path "N/A")
             (or org-path "N/A")
             (if exists "yes" "NO")
             (cond
              (disabled "disabled")
              (loaded "loaded")
              (deferred "deferred")
              (t "pending")))))

#+END_SRC

** Provide
#+BEGIN_SRC emacs-lisp
(provide 'core-modules)
;;; core-modules.el ends here
#+END_SRC
