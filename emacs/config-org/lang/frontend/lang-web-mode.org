* lang-web-mode.el
:PROPERTIES:
:HEADER-ARGS: :tangle (concat temporary-file-directory "lang-web-mode.el") :lexical t
:END:

** Headers

#+BEGIN_SRC emacs-lisp
  ;;; lang-web-mode -- Config for Web Development -*- lexical-binding: t; -*-

  ;; Filename: lang-web-mode.el
  ;; Description: Config for Web Development (HTML/CSS/JavaScript)
  ;; Author: mcge <mcgeq@outlook.com>
  ;; Copyright (C) 2024, mcge, all rights reserved.
  ;; Create   Date: 2025-01-04 15:00:00
  ;; Version: 0.1
  ;; Modified   By: mcge <mcgeq@outlook.com>
  ;; Last Modified: <2025-02-16 Sun 12:00>
  ;; Keywords:
  ;; Compatibility: GNU Emacs 31.0.50

  ;;; Commentary:
  ;;
  ;; Config for Web Development including HTML, CSS, JavaScript, Vue, etc.
  ;;

  ;;; Installation:
  ;;
  ;; Put lang-web-mode.el to your load-path.
  ;; The load-path is usually ~/elisp/.
  ;; It's set in your ~/.emacs like this:
  ;; (add-to-list 'load-path (expand-file-name "~/elisp"))
  ;;
  ;; And the following to your ~/.emacs startup file.
  ;;
  ;; (require 'lang-web-mode)
  ;;
  ;; No need more.

  ;;; Customize:
  ;;
  ;;
  ;;
  ;; All of the above can customize by:
  ;;      M-x customize-group RET init-aider RET

  ;;; Change log:
  ;;

#+END_SRC


** Require
#+BEGIN_SRC emacs-lisp
;;; Require:
(require 'lazy-load)
(require 'web-mode)
(require 'js)
(require 'instant-rename-tag)
(require 'highlight-matching-tag)
(require 'css-mode)
;;; Code:
#+END_SRC

** Code
#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; OS Config ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (featurep 'cocoa)
  ;; Initialize environment from user's shell to make eshell know every PATH by other shell.
  (require 'exec-path-from-shell)
  (exec-path-from-shell-initialize))

;; Associate file extensions with web-mode
;; Vue files use web-mode for proper syntax highlighting
(add-to-list 'auto-mode-alist '("\\.vue\\'" . web-mode))

;; HTML files: use html-ts-mode if available (Emacs 29+), fallback to web-mode
(if (and (fboundp 'html-ts-mode) (treesit-available-p))
    (add-to-list 'auto-mode-alist '("\\.html\\'" . html-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode)))

;; Note: .jsx/.tsx handled by lang-typescript if enabled

(setq web-mode-enable-auto-quoting nil) ;disable automatic insertion of double quotes, not easy to use if cursor in string

(highlight-matching-tag 1)

;; css
(setq css-indent-offset 2)

;; Emmit.
(setq web-mode-tag-auto-close-style 2) ;2 mean auto-close with > and </.
(setq web-mode-content-types-alist '(("vue" . "\\.vue\\'")))
(setq web-mode-css-indent-offset 2)       ; CSS 缩进（包含 HTML 的 CSS 部分及 CSS/LESS/SASS 文件）
(setq web-mode-code-indent-offset 2)      ; JavaScript 缩进（包含 SCRIPT 部分及 JS/JSX/TS/TSX 文件）
(setq web-mode-markup-indent-offset 2)    ; HTML 缩进（包含 HTML 文件及 Vue 的 TEMPLATE 部分）
(setq web-mode-enable-css-colorization t) ; 开启 CSS 颜色值显示
(setq web-mode-enable-auto-indentation nil) ; 禁用粘贴时自动格式化
(setq web-mode-enable-current-column-highlight nil)

(with-eval-after-load 'web-mode
  (setq tab-width 2))
#+END_SRC

** LSP Configuration
#+BEGIN_SRC emacs-lisp
;;; LSP配置 - 为 Web 文件启用 LSP Bridge (lazycat style)
(defun mcg-web-mode-lsp-setup ()
  "为 web-mode 启用 lsp-bridge，支持 Vue/HTML/JSX 文件"
  (when buffer-file-name
    (let ((ext (file-name-extension buffer-file-name)))
      (when (member ext '("vue" "html" "jsx" "tsx"))
        (lsp-bridge-mode 1)
        ;; Enable web-specific features
        (when (string= ext "vue")
          (setq-local lsp-bridge-enable-completion-in-string t))))))

(add-hook 'web-mode-hook #'mcg-web-mode-lsp-setup)
(add-hook 'html-mode-hook #'mcg-web-mode-lsp-setup)
(add-hook 'html-ts-mode-hook #'mcg-web-mode-lsp-setup)

;; 诊断函数：检查 Vue LSP 环境
(defun mcg-vue-check-lsp-environment ()
  "检查 Vue LSP 所需的环境配置"
  (interactive)
  (let ((results '())
        (tsdk-path (expand-file-name "~/AppData/Roaming/npm/node_modules/typescript/lib")))
    ;; 检查 vue-language-server
    (if (executable-find "vue-language-server")
        (push "✓ vue-language-server 已安装" results)
      (push "✗ vue-language-server 未安装 - 运行: npm install -g @vue/language-server" results))
    
    ;; 检查 typescript
    (if (executable-find "tsc")
        (push "✓ TypeScript 已安装" results)
      (push "✗ TypeScript 未安装 - 运行: npm install -g typescript" results))
    
    ;; 检查 tsdk 路径
    (if (file-directory-p tsdk-path)
        (push (format "✓ TypeScript SDK 路径存在: %s" tsdk-path) results)
      (push (format "✗ TypeScript SDK 路径不存在: %s" tsdk-path) results))
    
    ;; 检查当前 buffer
    (when (eq major-mode 'web-mode)
      (if lsp-bridge-mode
          (push "✓ 当前 Vue 文件已启用 lsp-bridge-mode" results)
        (push "✗ 当前 Vue 文件未启用 lsp-bridge-mode" results)))
    
    ;; 显示结果
    (with-current-buffer (get-buffer-create "*Vue LSP 诊断*")
      (erase-buffer)
      (insert "=== Vue LSP 环境检查 ===\n\n")
      (dolist (result (reverse results))
        (insert result "\n"))
      (insert "\n推荐的全局 npm 包:\n")
      (insert "  npm install -g typescript\n")
      (insert "  npm install -g @vue/language-server\n")
      (insert "  npm install -g typescript-language-server\n")
      (goto-char (point-min))
      (display-buffer (current-buffer)))))
#+END_SRC

** Keybindings
#+BEGIN_SRC emacs-lisp
;; Web-mode 快捷键 (lazycat style - 更符合直觉)
;; (lazy-load-set-keys fingertip-key-alist web-mode-map)
(lazy-load-local-keys
 '(
   ("M-s-SPC" . web-mode-element-content-select)  ; 选择元素内容
   ("C-s-l" . web-mode-element-clone)              ; 克隆元素
   ("C-M-SPC" . web-mode-mark-and-expand)         ; 标记并扩展
   ("C-:" . web-mode-comment-or-uncomment)         ; 注释/取消注释
   ("M-R" . instant-rename-tag)                    ; 重命名标签
   ("C-c C-n" . web-mode-tag-match)                ; 跳转到匹配标签
   ("C-c C-f" . web-mode-fold-or-unfold)           ; 折叠/展开
   ("C-c C-j" . web-mode-element-insert)           ; 插入元素
   )
 web-mode-map
 "web-mode-extension")
#+END_SRC

** Vue SFC Block Reorder
#+BEGIN_SRC emacs-lisp
;;; Vue 单文件组件块排序 - 排序为 script -> template -> style

(defvar mcg-vue-block-order '("script" "template" "style")
  "Vue SFC 块的期望顺序。")

(defun mcg-vue--find-block-bounds (block-name)
  "查找 Vue 块的起止位置，返回 (start . end) 或 nil。"
  (save-excursion
    (goto-char (point-min))
    ;; 匹配 <script>, <script setup>, <script lang="ts"> 等
    (let ((start-regex (format "^[ \t]*<%s\\(?:[ \t\n][^>]*\\)?>" block-name))
          (end-regex (format "^[ \t]*</%s>" block-name)))
      (when (re-search-forward start-regex nil t)
        (let ((start (match-beginning 0)))
          (when (re-search-forward end-regex nil t)
            (cons start (point))))))))

(defun mcg-vue--extract-block (block-name)
  "提取 Vue 块内容，返回字符串或 nil。"
  (when-let ((bounds (mcg-vue--find-block-bounds block-name)))
    (buffer-substring-no-properties (car bounds) (cdr bounds))))

(defun mcg-vue--get-block-positions ()
  "获取所有块的位置，返回 ((name . start-pos) ...) 按位置排序。"
  (let (positions)
    (dolist (name mcg-vue-block-order)
      (when-let ((bounds (mcg-vue--find-block-bounds name)))
        (push (cons name (car bounds)) positions)))
    (sort positions (lambda (a b) (< (cdr a) (cdr b))))))

(defun mcg-vue-reorder-blocks ()
  "重新排序 Vue SFC 块为: script -> template -> style。"
  (interactive)
  (unless (and buffer-file-name
               (string-match-p "\\.vue\\'" buffer-file-name))
    (user-error "Not a Vue file"))
  
  (let* ((positions (mcg-vue--get-block-positions))
         (current-order (mapcar #'car positions))
         (expected-order (seq-filter (lambda (b) (member b current-order))
                                     mcg-vue-block-order)))
    
    (if (equal current-order expected-order)
        (message "Vue blocks already in correct order: %s"
                 (string-join current-order " -> "))
      ;; 提取所有块内容
      (let ((blocks (mapcar (lambda (name)
                              (cons name (mcg-vue--extract-block name)))
                            expected-order)))
        ;; 删除所有内容
        (erase-buffer)
        ;; 按正确顺序插入
        (dolist (block blocks)
          (when (cdr block)
            (unless (bobp)
              (insert "\n\n"))
            (insert (cdr block))))
        (insert "\n")
        (message "Vue blocks reordered: %s" (string-join expected-order " -> "))))))

;; 保存 Vue 文件前自动排序块
(defun mcg-vue-reorder-before-save ()
  "保存前重排序 Vue 块。"
  (when (and (eq major-mode 'web-mode)
             buffer-file-name
             (string-match-p "\\.vue\\'" buffer-file-name))
    (mcg-vue-reorder-blocks)))

;; 启用保存时自动排序（仅对 .vue 文件生效）
(add-hook 'before-save-hook #'mcg-vue-reorder-before-save)

;; 手动排序快捷键
(defun mcg-vue-setup-reorder-keys ()
  "设置 Vue 块排序快捷键"
  (when (and buffer-file-name
             (string-match-p "\\.vue\\'" buffer-file-name))
    (local-set-key (kbd "C-c C-o") #'mcg-vue-reorder-blocks)))

(add-hook 'web-mode-hook #'mcg-vue-setup-reorder-keys)
#+END_SRC

** Enhanced Web Development Features
#+BEGIN_SRC emacs-lisp
;;; 增强的 Web 开发特性 (lazycat style)

;; Auto-pair 特殊处理：在字符串中智能配对
(defun mcg-web-mode-smartparens-config ()
  "配置 web-mode 的智能配对"
  (when (featurep 'smartparens)
    (sp-with-modes '(web-mode)
      (sp-local-pair "<" ">")
      (sp-local-pair "{" "}")
      (sp-local-pair "{{" "}}")  ; Vue template syntax
      (sp-local-pair "{%" "%}"))))  ; Jinja/Django template

(with-eval-after-load 'web-mode
  (mcg-web-mode-smartparens-config))

;; Emmet 智能展开
(defun mcg-web-mode-emmet-setup ()
  "配置 Emmet 快速展开"
  (when (featurep 'emmet-mode)
    (emmet-mode 1)
    (setq-local emmet-expand-jsx-className? t)  ; Support JSX className
    (setq-local emmet-move-cursor-between-quotes t)))

(add-hook 'web-mode-hook #'mcg-web-mode-emmet-setup)
(add-hook 'html-mode-hook #'mcg-web-mode-emmet-setup)

;; Vue 组件快速插入
(defun mcg-insert-vue-component ()
  "插入 Vue 3 组件模板"
  (interactive)
  (let ((component-name (read-string "Component name: ")))
    (insert (format "<script setup lang=\"ts\">\nimport { ref } from 'vue'\n\n</script>\n\n"))
    (insert (format "<template>\n  <div class=\"%s\">\n    \n  </div>\n</template>\n\n" 
                    (downcase component-name)))
    (insert "<style scoped>\n\n</style>\n")))

(defun mcg-insert-react-component ()
  "插入 React 函数组件模板"
  (interactive)
  (let ((component-name (read-string "Component name: ")))
    (insert (format "import React from 'react';\n\n"))
    (insert (format "interface %sProps {\n  // Define props here\n}\n\n" component-name))
    (insert (format "export const %s: React.FC<%sProps> = (props) => {\n" 
                    component-name component-name))
    (insert "  return (\n    <div>\n      \n    </div>\n  );\n};\n")))

;; 快捷键绑定
(lazy-load-local-keys
 '(
   ("C-c v" . mcg-insert-vue-component)
   ("C-c r" . mcg-insert-react-component)
   )
 web-mode-map
 "web-mode-component-templates")
#+END_SRC

** Ends
#+BEGIN_SRC emacs-lisp
(provide 'lang-web-mode)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; lang-web-mode.el ends here
#+END_SRC

