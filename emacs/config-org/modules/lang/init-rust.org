* init-rust.el
:PROPERTIES:
:HEADER-ARGS: :tangle init-rust.el :lexical t
:END:

** Headers
#+BEGIN_SRC emacs-lisp
  ;;; init-rust.el --- Rust Language Support for MCG Emacs -*- lexical-binding: t; -*-

  ;; Filename: init-rust.el
  ;; Description: Rust 语言支持模块
  ;; Author: mcge <mcgeq@outlook.com>
  ;; Copyright (C) 2024-2026, mcge, all rights reserved.
  ;; Create   Date: 2026-01-07
  ;; Version: 3.0
  ;; Keywords: rust, rust-analyzer, development
  ;; Compatibility: GNU Emacs 29.0+

  ;;; Commentary:
  ;;
  ;; MCG Emacs 配置架构的 Rust 语言支持模块，提供：
  ;; - rust-mode / rust-ts-mode 配置
  ;; - rust-analyzer LSP 集成（通过 +lsp 模块）
  ;; - Cargo 命令集成
  ;; - 代码格式化（rustfmt）
  ;; - 测试运行支持
  ;;
  ;; 模块元数据:
  ;; :depends (+lsp)
  ;; :defer t
  ;;

#+END_SRC

** Dependencies
#+BEGIN_SRC emacs-lisp
;;; Dependencies

(require 'core-lib)

;; 确保 +lsp 模块已加载
(when (and (boundp 'mcg-module-enabled-p)
           (fboundp 'mcg-module-enabled-p)
           (mcg-module-enabled-p :lang 'lsp))
  (require '+lsp nil t))

#+END_SRC

** Rust Mode Configuration
#+BEGIN_SRC emacs-lisp
;;; Rust 基础配置

;; 加载 rust-mode 扩展
(mcg-require-extension "lsp/rust-mode" 'rust-mode)

;; 使用 rust-ts-mode（如果可用）
(when (and (fboundp 'treesit-available-p)
           (treesit-available-p))
  (add-to-list 'major-mode-remap-alist '(rust-mode . rust-ts-mode)))

;; 文件关联
(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
(add-to-list 'auto-mode-alist '("Cargo\\.toml\\'" . toml-ts-mode))

;; Rust 缩进设置
(setq rust-indent-offset 4)

#+END_SRC

** Cargo Integration
#+BEGIN_SRC emacs-lisp
;;; Cargo 命令集成

(defun mcg/rust-cargo-build ()
  "运行 cargo build。"
  (interactive)
  (let ((compilation-scroll-output t))
    (compile "cargo build")))

(defun mcg/rust-cargo-run ()
  "运行 cargo run。"
  (interactive)
  (let ((compilation-scroll-output t))
    (compile "cargo run")))

(defun mcg/rust-cargo-test ()
  "运行 cargo test。"
  (interactive)
  (let ((compilation-scroll-output t))
    (compile "cargo test")))

(defun mcg/rust-cargo-check ()
  "运行 cargo check。"
  (interactive)
  (let ((compilation-scroll-output t))
    (compile "cargo check")))

(defun mcg/rust-cargo-clippy ()
  "运行 cargo clippy。"
  (interactive)
  (let ((compilation-scroll-output t))
    (compile "cargo clippy")))

(defun mcg/rust-cargo-doc ()
  "运行 cargo doc --open。"
  (interactive)
  (let ((compilation-scroll-output t))
    (compile "cargo doc --open")))

(defun mcg/rust-cargo-fmt ()
  "运行 cargo fmt。"
  (interactive)
  (let ((file (buffer-file-name)))
    (when file
      (save-buffer)
      (if (zerop (call-process "cargo" nil nil nil "fmt"))
          (progn
            (revert-buffer t t t)
            (message "Formatted with cargo fmt"))
        (message "cargo fmt failed")))))

#+END_SRC

** Test Functions
#+BEGIN_SRC emacs-lisp
;;; 测试支持

(defun mcg/rust-test-current-fn ()
  "运行光标所在的测试函数。"
  (interactive)
  (let ((fn-name (mcg--rust-current-fn-name)))
    (if fn-name
        (let ((compilation-scroll-output t))
          (compile (format "cargo test %s -- --nocapture" fn-name)))
      (message "No test function at point"))))

(defun mcg--rust-current-fn-name ()
  "获取光标所在的函数名。"
  (save-excursion
    (when (re-search-backward "^\\s-*\\(?:pub\\s-+\\)?\\(?:async\\s-+\\)?fn\\s-+\\([a-zA-Z_][a-zA-Z0-9_]*\\)" nil t)
      (match-string-no-properties 1))))

(defun mcg/rust-test-module ()
  "运行当前模块的所有测试。"
  (interactive)
  (let* ((file (buffer-file-name))
         (module-name (when file
                        (file-name-sans-extension
                         (file-name-nondirectory file)))))
    (if module-name
        (let ((compilation-scroll-output t))
          (compile (format "cargo test %s::" module-name)))
      (message "Cannot determine module name"))))

#+END_SRC

** Format on Save
#+BEGIN_SRC emacs-lisp
;;; 保存时格式化

(defvar mcg-rust-format-on-save t
  "是否在保存时自动格式化 Rust 代码。")

(defun mcg-rust-format-buffer ()
  "使用 rustfmt 格式化当前 buffer。"
  (interactive)
  (if (and (bound-and-true-p lsp-bridge-mode)
           (fboundp 'lsp-bridge-code-format))
      (lsp-bridge-code-format)
    ;; 回退到直接调用 rustfmt
    (when (executable-find "rustfmt")
      (let ((temp-file (make-temp-file "rustfmt" nil ".rs")))
        (unwind-protect
            (progn
              (write-region (point-min) (point-max) temp-file nil 'silent)
              (when (zerop (call-process "rustfmt" nil nil nil temp-file))
                (let ((formatted (with-temp-buffer
                                   (insert-file-contents temp-file)
                                   (buffer-string))))
                  (erase-buffer)
                  (insert formatted)
                  (message "Formatted with rustfmt"))))
          (delete-file temp-file))))))

(defun mcg-rust-maybe-format-on-save ()
  "保存时可能格式化 Rust 代码。"
  (when (and mcg-rust-format-on-save
             (or (derived-mode-p 'rust-mode)
                 (derived-mode-p 'rust-ts-mode)))
    (mcg-rust-format-buffer)))

;; 注意：格式化由 +lsp 模块的 mcg-lsp-format-on-save 统一处理
;; 这里不再添加 before-save-hook

#+END_SRC

** Keybindings
#+BEGIN_SRC emacs-lisp
;;; 快捷键配置

(defun mcg-rust-setup-keybindings ()
  "设置 Rust 模式快捷键。"
  ;; Cargo 命令 (C-c C-u 前缀)
  (local-set-key (kbd "C-c C-u C-b") #'mcg/rust-cargo-build)
  (local-set-key (kbd "C-c C-u C-r") #'mcg/rust-cargo-run)
  (local-set-key (kbd "C-c C-u C-t") #'mcg/rust-cargo-test)
  (local-set-key (kbd "C-c C-u C-k") #'mcg/rust-cargo-check)
  (local-set-key (kbd "C-c C-u C-l") #'mcg/rust-cargo-clippy)
  (local-set-key (kbd "C-c C-u C-d") #'mcg/rust-cargo-doc)
  (local-set-key (kbd "C-c C-u C-f") #'mcg/rust-cargo-fmt)
  
  ;; 测试 (C-c t 前缀)
  (local-set-key (kbd "C-c t f") #'mcg/rust-test-current-fn)
  (local-set-key (kbd "C-c t m") #'mcg/rust-test-module)
  (local-set-key (kbd "C-c t t") #'mcg/rust-cargo-test)
  
  ;; 格式化
  (local-set-key (kbd "C-c r f") #'mcg-rust-format-buffer))

(add-hook 'rust-mode-hook #'mcg-rust-setup-keybindings)
(add-hook 'rust-ts-mode-hook #'mcg-rust-setup-keybindings)

#+END_SRC

** Project Detection
#+BEGIN_SRC emacs-lisp
;;; 项目检测

(defun mcg-rust-project-p ()
  "检测是否为 Rust 项目。"
  (when-let ((project-root (when (project-current)
                             (project-root (project-current)))))
    (file-exists-p (expand-file-name "Cargo.toml" project-root))))

(defun mcg/rust-project-info ()
  "显示 Rust 项目信息。"
  (interactive)
  (if (mcg-rust-project-p)
      (let* ((project-root (project-root (project-current)))
             (cargo-toml (expand-file-name "Cargo.toml" project-root)))
        (message "Rust project: %s" project-root))
    (message "Not in a Rust project")))

#+END_SRC

** Tool Status Check
#+BEGIN_SRC emacs-lisp
;;; 工具状态检查

(defun mcg/rust-check-tools ()
  "检查 Rust 开发工具是否已安装。"
  (interactive)
  (let ((tools '(("rustc" . "rustup install stable")
                 ("cargo" . "rustup install stable")
                 ("rustfmt" . "rustup component add rustfmt")
                 ("clippy" . "rustup component add clippy")
                 ("rust-analyzer" . "rustup component add rust-analyzer"))))
    (with-help-window "*Rust Tools Status*"
      (princ "═══════════════════════════════════════════\n")
      (princ "   Rust 开发工具状态\n")
      (princ "═══════════════════════════════════════════\n\n")
      (dolist (tool tools)
        (let ((name (car tool))
              (install-cmd (cdr tool)))
          (princ (format "%-16s %s\n"
                         name
                         (if (executable-find name)
                             "✓ 已安装"
                           (format "✗ 未安装 (%s)" install-cmd))))))
      (princ "\n═══════════════════════════════════════════\n")
      (princ "\n推荐安装命令:\n")
      (princ "  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n")
      (princ "  rustup component add rustfmt clippy rust-analyzer\n"))))

#+END_SRC

** Keybindings Summary
#+BEGIN_SRC emacs-lisp
;;; 快捷键总结

;; Cargo 命令 (C-c C-u 前缀):
;; C-c C-u C-b   - cargo build
;; C-c C-u C-r   - cargo run
;; C-c C-u C-t   - cargo test
;; C-c C-u C-k   - cargo check
;; C-c C-u C-l   - cargo clippy
;; C-c C-u C-d   - cargo doc --open
;; C-c C-u C-f   - cargo fmt
;;
;; 测试 (C-c t 前缀):
;; C-c t f       - 运行当前函数测试
;; C-c t m       - 运行当前模块测试
;; C-c t t       - 运行所有测试
;;
;; 格式化:
;; C-c r f       - 格式化代码
;;
;; LSP (由 +lsp 模块提供):
;; M-.           - 跳转定义
;; M-,           - 返回
;; M-?           - 查找引用
;; C-c r r       - 重命名

#+END_SRC

** Provide
#+BEGIN_SRC emacs-lisp
(provide 'init-rust)
;;; init-rust.el ends here
#+END_SRC
