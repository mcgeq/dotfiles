* init-lsp.el
:PROPERTIES:
:HEADER-ARGS: :tangle init-lsp.el :lexical t
:END:

** Headers
#+BEGIN_SRC emacs-lisp
  ;;; init-lsp.el --- Unified LSP Configuration for MCG Emacs -*- lexical-binding: t; -*-

  ;; Filename: init-lsp.el
  ;; Description: Unified LSP configuration module
  ;; Author: mcge <mcgeq@outlook.com>
  ;; Copyright (C) 2024-2026, mcge, all rights reserved.
  ;; Create   Date: 2026-01-07
  ;; Version: 3.0
  ;; Keywords: lsp, language-server, development
  ;; Compatibility: GNU Emacs 29.0+

  ;;; Commentary:
  ;;
  ;; Unified LSP module for MCG Emacs, responsible for:
  ;; - LSP Bridge configuration
  ;; - Unified keybindings
  ;; - LSP server mapping
  ;; - Auto-format on save
  ;; - LSP status queries
  ;;
  ;; Module metadata:
  ;; :depends ()
  ;; :defer nil
  ;;

#+END_SRC

** Dependencies
#+BEGIN_SRC emacs-lisp
;;; Dependencies

(require 'cl-lib)
(require 'core-lib)

#+END_SRC

** LSP Server Mapping
#+BEGIN_SRC emacs-lisp
;;; LSP Server Mapping

(defvar mcg-lsp-servers
  '((rust-mode . "rust-analyzer")
    (rust-ts-mode . "rust-analyzer")
    (python-mode . "python-ty-ruff")
    (python-ts-mode . "python-ty-ruff")
    (typescript-mode . "typescript-biome")
    (typescript-ts-mode . "typescript-biome")
    (tsx-ts-mode . "typescript-biome")
    (js-mode . "typescript-biome")
    (js-ts-mode . "typescript-biome")
    (web-mode . "vue-full")
    (zig-mode . "zls")
    (zig-ts-mode . "zls")
    (c-mode . "clangd")
    (c-ts-mode . "clangd")
    (c++-mode . "clangd")
    (c++-ts-mode . "clangd")
    (lua-mode . "lua-language-server")
    (lua-ts-mode . "lua-language-server")
    (clojure-mode . "clojure-lsp")
    (clojure-ts-mode . "clojure-lsp"))
  "Language mode to LSP server mapping.

Each entry format is (MODE . SERVER-NAME).
SERVER-NAME corresponds to lsp-bridge server configuration.")

#+END_SRC

** Unified Keybindings
#+BEGIN_SRC emacs-lisp
;;; Unified Keybindings

(defvar mcg-lsp-keymap
  '(;; Navigation
    ("M-." . lsp-bridge-find-def)
    ("M-," . lsp-bridge-find-def-return)
    ("M-?" . lsp-bridge-find-references)
    
    ;; Documentation
    ("C-h ." . lsp-bridge-lookup-documentation)
    ("C-h ," . lsp-bridge-show-signature)
    
    ;; Refactoring
    ("C-c r r" . lsp-bridge-rename)
    ("C-c r a" . lsp-bridge-code-action)
    ("C-c r f" . lsp-bridge-code-format)
    ("C-c r i" . mcg-lsp-organize-imports)
    
    ;; Diagnostics (M-g prefix - standard Emacs "goto" prefix)
    ("M-g n" . lsp-bridge-diagnostic-jump-next)
    ("M-g p" . lsp-bridge-diagnostic-jump-prev)
    ("M-g l" . lsp-bridge-diagnostic-list)
    
    ;; Workspace
    ("C-c r s" . lsp-bridge-workspace-list-symbols))
  "Unified LSP keybindings mapping.

All LSP-enabled language modes use the same keybindings:
- M-. Jump to definition
- M-, Return
- M-? Find references
- C-c r r Rename
- C-c r f Format")

(defun mcg-lsp-setup-keybindings ()
  "Setup unified LSP keybindings.

This function is called in lsp-bridge-mode-hook,
setting up keybindings defined in mcg-lsp-keymap for current buffer."
  (dolist (binding mcg-lsp-keymap)
    (local-set-key (kbd (car binding)) (cdr binding))))

#+END_SRC

** LSP Bridge Configuration
#+BEGIN_SRC emacs-lisp
;;; LSP Bridge Configuration

(defvar mcg-lsp-user-langserver-dir nil
  "User custom LSP server configuration directory.")

(defvar mcg-lsp-user-multiserver-dir nil
  "User custom multi-server configuration directory.")

;; Set default custom server directories
(setq mcg-lsp-user-langserver-dir (expand-file-name "langservers" mcg-emacs-dir))
(setq mcg-lsp-user-multiserver-dir (expand-file-name "multiservers" mcg-emacs-dir))

(cl-defun mcg-lsp-setup ()
  "Setup LSP Bridge general configuration.

This function configures lsp-bridge core options, including:
- Performance optimization
- Completion settings
- Diagnostics settings
- Signature help"
  ;; Load lsp-bridge extension
  (unless (mcg-require-extension "lsp/lsp-bridge" 'lsp-bridge)
    (mcg-log "Warning: lsp-bridge extension not found")
    (cl-return-from mcg-lsp-setup nil))
  
  ;; Set custom server directories
  (when mcg-lsp-user-langserver-dir
    (setq lsp-bridge-user-langserver-dir mcg-lsp-user-langserver-dir))
  (when mcg-lsp-user-multiserver-dir
    (setq lsp-bridge-user-multiserver-dir mcg-lsp-user-multiserver-dir))
  
  ;; ===== Core Features =====
  (setq lsp-bridge-enable-completion-in-minibuffer t)
  (setq lsp-bridge-signature-show-function 'lsp-bridge-signature-show-with-frame)
  (setq lsp-bridge-signature-show-with-frame-position "bottom-right")
  (setq lsp-bridge-enable-with-tramp t)
  (setq lsp-bridge-enable-org-babel t)
  
  ;; ===== Performance Optimization =====
  (setq lsp-bridge-enable-inlay-hint nil)  ; Disable for performance
  (setq lsp-bridge-semantic-tokens nil)    ; Disable semantic tokens
  (setq lsp-bridge-diagnostic-fetch-idle 0.5)
  (setq lsp-bridge-signature-help-fetch-idle 0.8)
  
  ;; ===== Diagnostics Settings =====
  (setq lsp-bridge-enable-diagnostics t)
  (setq lsp-bridge-enable-hover-diagnostic t)
  (setq lsp-bridge-code-action-enable-popup-tip t)
  
  ;; ===== Completion Settings =====
  (setq lsp-bridge-enable-search-words t)
  (setq lsp-bridge-enable-auto-import t)
  (setq lsp-bridge-enable-auto-format-code t)  ; Enable LSP auto-format
  (setq lsp-bridge-find-def-select-in-open-windows t)
  (setq lsp-bridge-enable-rename-file t)
  
  ;; ===== ACM Configuration =====
  (setq acm-enable-capf t)
  (setq acm-enable-quick-access t)
  (setq acm-backend-yas-match-by-trigger-keyword t)
  (setq acm-enable-tabnine nil)
  (setq acm-enable-codeium nil)
  (setq acm-candidate-match-function 'regexp-quote)
  (setq acm-enable-lsp-workspace-symbol nil)
  (setq acm-enable-doc nil)
  (setq acm-doc-frame-pos 'bottom-right)
  (setq acm-enable-icon t)
  (setq acm-enable-doc-markdown-render 'async)
  (setq acm-candidate-match-max-length 50)
  (setq acm-enable-preview nil)
  (setq acm-menu-length 8)
  (setq acm-enable-path t)
  (setq acm-enable-search-file-words nil)
  (setq acm-frame-max-width 100)
  
  ;; ===== Completion Trigger Configuration =====
  (setq acm-backend-lsp-candidate-min-length 1)
  (setq acm-backend-elisp-candidate-min-length 1)
  (setq acm-backend-yas-candidate-min-length 1)
  (setq acm-backend-search-file-words-candidate-min-length 2)
  
  ;; ===== Multi-server Configuration =====
  ;; Override default lsp-bridge multi-server config (must use setq to replace defaults)
  (setq lsp-bridge-multi-lang-server-extension-list
        '(;; TypeScript/JavaScript with Biome (replaces default typescript_eslint)
          (("ts") . "typescript-biome")
          (("tsx") . "typescript-biome")
          (("js") . "typescript-biome")
          (("jsx") . "typescript-biome")
          ;; Vue with volar + emmet-ls + biome
          (("vue") . "vue-full")
          ;; Python with ty + ruff
          (("py") . "ty_ruff")
          (("pyi") . "ty_ruff")
          ;; Keep some useful defaults
          (("component.html") . "angular_template_html")
          (("component.ts") . "angular_template_typescript")))
  
  ;; Setup keybindings hook
  (add-hook 'lsp-bridge-mode-hook #'mcg-lsp-setup-keybindings)
  
  ;; Enable global lsp-bridge-mode
  (global-lsp-bridge-mode)
  
  (mcg-log "LSP setup complete"))

#+END_SRC

** Biome Formatting
#+BEGIN_SRC emacs-lisp
;;; Biome Formatting (for TypeScript/JavaScript/Vue)

(defun mcg-ts-format-with-biome ()
  "Format and fix code using Biome (same as nvim conform config)."
  (interactive)
  (if (executable-find "biome")
      (let ((file (buffer-file-name)))
        (when file
          (save-buffer)
          ;; 使用 check --write --unsafe，与 nvim conform 配置一致
          (let ((exit-code (call-process "biome" nil "*biome*" nil
                                         "check" "--write" "--unsafe" file)))
            (if (zerop exit-code)
                (progn
                  (revert-buffer t t t)
                  (message "Formatted with Biome"))
              ;; exit code 1 表示有修复，也算成功
              (if (= exit-code 1)
                  (progn
                    (revert-buffer t t t)
                    (message "Biome applied fixes"))
                (message "Biome failed (exit %d). Check *biome* buffer" exit-code))))))
    (message "Biome not found. Install with: npm install -g @biomejs/biome")))

(defun mcg/biome-check ()
  "Check code using Biome (lint + format)."
  (interactive)
  (if (executable-find "biome")
      (let ((compilation-scroll-output t))
        (compile (format "biome check %s" (shell-quote-argument (buffer-file-name)))))
    (message "Biome not found. Install with: npm install -g @biomejs/biome")))

(defun mcg/biome-fix ()
  "Auto-fix code using Biome (same as format)."
  (interactive)
  (mcg-ts-format-with-biome))

(defun mcg-ts-format-with-prettier ()
  "Format code using Prettier (fallback)."
  (interactive)
  (if (executable-find "prettier")
      (let* ((temp-file (make-temp-file "prettier" nil
                                        (concat "." (file-name-extension (buffer-file-name)))))
             (output-buffer (get-buffer-create "*prettier*")))
        (write-region (point-min) (point-max) temp-file)
        (if (zerop (call-process "prettier" nil output-buffer nil
                                 "--write" temp-file))
            (progn
              (erase-buffer)
              (insert-file-contents temp-file)
              (delete-file temp-file)
              (message "Formatted with Prettier"))
          (message "Prettier formatting failed")))
    (message "Prettier not found. Install with: npm install -g prettier")))

(defun mcg-ts-format-buffer ()
  "Format TypeScript/JavaScript/Vue code (prefer Biome)."
  (interactive)
  (cond
   ((executable-find "biome") (mcg-ts-format-with-biome))
   ((executable-find "prettier") (mcg-ts-format-with-prettier))
   (t (message "No formatter found. Install biome or prettier"))))

#+END_SRC

** Format on Save
#+BEGIN_SRC emacs-lisp
;;; Format on Save

(defvar mcg-lsp-format-on-save-modes
  '(;; Rust
    rust-mode
    rust-ts-mode
    ;; Zig
    zig-mode
    zig-ts-mode
    ;; C/C++
    c-mode
    c-ts-mode
    c++-mode
    c++-ts-mode)
  "List of modes with LSP format-on-save enabled.
Note: TypeScript/Vue use mcg-ts-format-buffer (biome CLI), Python uses lsp-bridge.")

(defvar mcg-biome-format-on-save-modes
  '(;; TypeScript/JavaScript
    typescript-mode
    typescript-ts-mode
    tsx-ts-mode
    js-mode
    js-ts-mode
    ;; Vue
    web-mode)
  "List of modes with Biome CLI format-on-save enabled.")

(defvar mcg-lsp-organize-imports-modes
  '()  ; Disabled - biome handles imports for TypeScript, ruff for Python
  "List of modes with organize-imports-on-save enabled.
Note: Biome handles imports for TypeScript, ruff LSP handles Python imports.")

(defvar mcg-lsp-format-on-save-enabled t
  "Whether format-on-save is enabled.")

(defvar mcg-lsp-organize-imports-on-save-enabled t
  "Whether organize-imports-on-save is enabled.")

(defvar mcg--formatting-in-progress nil
  "Flag to prevent recursive formatting.")

(defun mcg-lsp-format-on-save-before ()
  "Format buffer before save (for LSP-based formatters).

Only handles modes that use lsp-bridge-code-format."
  (when (and mcg-lsp-format-on-save-enabled
             (not mcg--formatting-in-progress)
             (member major-mode mcg-lsp-format-on-save-modes))
    (when (and (fboundp 'lsp-bridge-mode)
               (bound-and-true-p lsp-bridge-mode))
      (lsp-bridge-code-format))))

(defun mcg-lsp-format-on-save-after ()
  "Format buffer after save (for CLI-based formatters like biome).

Handles TypeScript/JavaScript/Vue files using biome CLI."
  (when (and mcg-lsp-format-on-save-enabled
             (not mcg--formatting-in-progress)
             (member major-mode mcg-biome-format-on-save-modes))
    (let ((mcg--formatting-in-progress t))
      (mcg-ts-format-after-save))))

(defun mcg-ts-format-after-save ()
  "Format current file with biome after save (no recursive save)."
  (when-let* ((file (buffer-file-name)))
    (if (executable-find "biome")
        (let ((exit-code (call-process "biome" nil "*biome*" nil
                                       "check" "--write" "--unsafe" file)))
          (cond
           ((zerop exit-code)
            (revert-buffer t t t)
            (message "Formatted with Biome"))
           ((= exit-code 1)
            (revert-buffer t t t)
            (message "Biome applied fixes"))
           (t
            (message "Biome failed (exit %d). Check *biome* buffer" exit-code))))
      (message "Biome not found"))))

(defun mcg/toggle-format-on-save ()
  "Toggle format-on-save."
  (interactive)
  (setq mcg-lsp-format-on-save-enabled (not mcg-lsp-format-on-save-enabled))
  (message "Format on save: %s"
           (if mcg-lsp-format-on-save-enabled "enabled" "disabled")))

(defun mcg/toggle-organize-imports-on-save ()
  "Toggle organize-imports-on-save."
  (interactive)
  (setq mcg-lsp-organize-imports-on-save-enabled (not mcg-lsp-organize-imports-on-save-enabled))
  (message "Organize imports on save: %s"
           (if mcg-lsp-organize-imports-on-save-enabled "enabled" "disabled")))

;; Enable format-on-save
;; before-save-hook: LSP-based formatters (Rust, Zig, C/C++)
;; after-save-hook: CLI-based formatters (biome for TypeScript/Vue)
(add-hook 'before-save-hook #'mcg-lsp-format-on-save-before)
(add-hook 'after-save-hook #'mcg-lsp-format-on-save-after)

#+END_SRC

** Utility Functions
#+BEGIN_SRC emacs-lisp
;;; Utility Functions

(defun mcg-lsp-format-buffer ()
  "Format current buffer based on major-mode.

TypeScript/JavaScript/Vue: Use biome CLI (mcg-ts-format-buffer)
Other languages: Use lsp-bridge-code-format"
  (interactive)
  (cond
   ;; TypeScript/JavaScript/Vue: Use biome CLI
   ((member major-mode mcg-biome-format-on-save-modes)
    (mcg-ts-format-buffer))
   ;; Other languages: Use lsp-bridge
   ((and (fboundp 'lsp-bridge-mode)
         (bound-and-true-p lsp-bridge-mode))
    (lsp-bridge-code-format))
   (t
    (message "No formatter available for this buffer"))))

(defun mcg-lsp-organize-imports ()
  "Organize imports in current buffer.

Select appropriate tool based on current major-mode:
- Python: Use ruff
- Rust: Use rustfmt
- Others: Try LSP code action"
  (interactive)
  (cond
   ;; Python: Use ruff
   ((member major-mode '(python-mode python-ts-mode))
    (if (executable-find "ruff")
        (let ((file (buffer-file-name)))
          (when file
            (save-buffer)
            (if (zerop (call-process "ruff" nil nil nil "check" "--select" "I" "--fix" file))
                (progn
                  (revert-buffer t t t)
                  (message "Sorted imports with ruff"))
              (message "ruff: no import changes needed"))))
      (message "ruff not found")))
   
   ;; Rust: Use rustfmt
   ((member major-mode '(rust-mode rust-ts-mode))
    (lsp-bridge-code-format)
    (message "Rust imports organized via rustfmt"))
   
   ;; Other languages: Try LSP code action
   ((bound-and-true-p lsp-bridge-mode)
    (lsp-bridge-code-action))
   
   (t
    (message "No import organizer available for this mode"))))

(defun mcg-lsp-restart ()
  "Restart LSP server."
  (interactive)
  (when (bound-and-true-p lsp-bridge-mode)
    (lsp-bridge-restart-process)
    (message "LSP server restarted")))

#+END_SRC

** LSP Status Command
#+BEGIN_SRC emacs-lisp
;;; LSP Status Command

(defun mcg-lsp-check-server-available (server-name)
  "Check if LSP server is available.

Arguments:
- SERVER-NAME: Server executable name

Returns t if server is available in PATH."
  (executable-find server-name))

(defun mcg-lsp-status ()
  "Show status of all LSP servers.

Interactive command showing availability of various language LSP servers."
  (interactive)
  (let ((servers '(("Python (ty)" . "ty")
                   ("Python (ruff)" . "ruff")
                   ("TypeScript" . "typescript-language-server")
                   ("Biome" . "biome")
                   ("Rust" . "rust-analyzer")
                   ("Zig" . "zls")
                   ("C/C++ (clangd)" . "clangd")
                   ("Lua" . "lua-language-server")
                   ("Clojure" . "clojure-lsp"))))
    (with-help-window "*MCG LSP Status*"
      (princ "═══════════════════════════════════\n")
      (princ "   LSP Server Availability\n")
      (princ "═══════════════════════════════════\n\n")
      (dolist (server servers)
        (let ((name (car server))
              (executable (cdr server)))
          (princ (format "%-20s %s\n"
                         name
                         (if (mcg-lsp-check-server-available executable)
                             "✓ Available"
                           "✗ Not found")))))
      (princ "\n═══════════════════════════════════\n")
      (princ "\nInstallation instructions:\n")
      (princ "  Python (ty):   uv tool install ty\n")
      (princ "  Python (ruff): uv tool install ruff\n")
      (princ "  TypeScript:    npm install -g typescript-language-server\n")
      (princ "  Biome:         npm install -g @biomejs/biome\n")
      (princ "  Rust:          rustup component add rust-analyzer\n")
      (princ "  Zig:           Download from github.com/zigtools/zls\n")
      (princ "  C/C++:         Install clangd from LLVM\n")
      (princ "  Lua:           Install lua-language-server\n")
      (princ "  Clojure:       Install clojure-lsp\n"))))

#+END_SRC

** Project Detection
#+BEGIN_SRC emacs-lisp
;;; Project Detection

(defun mcg-lsp-detect-project-type ()
  "Detect current project type.

Detect project type based on files in project root.
Returns project type symbol, such as 'python, 'rust, 'javascript, etc."
  (when-let* ((project-root (when (project-current)
                              (project-root (project-current)))))
    (cond
     ;; Python
     ((or (file-exists-p (expand-file-name "setup.py" project-root))
          (file-exists-p (expand-file-name "pyproject.toml" project-root))
          (file-exists-p (expand-file-name "requirements.txt" project-root)))
      'python)
     
     ;; JavaScript/TypeScript
     ((or (file-exists-p (expand-file-name "package.json" project-root))
          (file-exists-p (expand-file-name "tsconfig.json" project-root)))
      'javascript)
     
     ;; Rust
     ((file-exists-p (expand-file-name "Cargo.toml" project-root))
      'rust)
     
     ;; Zig
     ((file-exists-p (expand-file-name "build.zig" project-root))
      'zig)
     
     ;; C/C++
     ((or (file-exists-p (expand-file-name "CMakeLists.txt" project-root))
          (file-exists-p (expand-file-name "Makefile" project-root))
          (file-exists-p (expand-file-name "compile_commands.json" project-root)))
      'c-cpp)
     
     ;; Clojure
     ((or (file-exists-p (expand-file-name "deps.edn" project-root))
          (file-exists-p (expand-file-name "project.clj" project-root)))
      'clojure)
     
     (t 'unknown))))

(defun mcg/lsp-project-info ()
  "Show current project information."
  (interactive)
  (let ((project-type (mcg-lsp-detect-project-type))
        (project-root (when (project-current)
                        (project-root (project-current)))))
    (message "Project: %s | Type: %s"
             (or project-root "None")
             (or project-type "unknown"))))

#+END_SRC

** Help Command
#+BEGIN_SRC emacs-lisp
;;; Help Command

(defun mcg/lsp-help ()
  "Show LSP keybindings and command help."
  (interactive)
  (with-help-window "*MCG LSP Help*"
    (princ "
╔═══════════════════════════════════════════╗
║       MCG LSP Keybindings                 ║
╚═══════════════════════════════════════════╝

NAVIGATION:
  M-.        - Go to definition
  M-,        - Return from definition
  M-?        - Find references

DOCUMENTATION:
  C-h .      - Show documentation
  C-h ,      - Show signature

REFACTORING:
  C-c r r    - Rename symbol
  C-c r a    - Code action
  C-c r f    - Format buffer
  C-c r i    - Organize imports

DIAGNOSTICS:
  M-g n      - Next diagnostic
  M-g p      - Previous diagnostic
  M-g l      - List all diagnostics

WORKSPACE:
  C-c r s    - List workspace symbols

═══════════════════════════════════════════

QUICK COMMANDS:
  M-x mcg-lsp-format-buffer   - Format buffer
  M-x mcg-lsp-organize-imports - Organize imports
  M-x mcg-lsp-restart         - Restart LSP server
  M-x mcg-lsp-status          - Check server availability
  M-x mcg/lsp-project-info    - Show project info

═══════════════════════════════════════════

SETTINGS:
  M-x mcg/toggle-format-on-save
    Toggle automatic formatting on save
  M-x mcg/toggle-organize-imports-on-save
    Toggle automatic import organization on save

Current status:
  Format on save: ")
    (princ (if mcg-lsp-format-on-save-enabled "✓ Enabled" "✗ Disabled"))
    (princ "\n  Organize imports on save: ")
    (princ (if mcg-lsp-organize-imports-on-save-enabled "✓ Enabled" "✗ Disabled"))
    (princ "\n\n═══════════════════════════════════════════\n")))

#+END_SRC

** Quick Aliases
#+BEGIN_SRC emacs-lisp
;;; Quick Aliases

(defalias 'lsp-format #'mcg-lsp-format-buffer)
(defalias 'lsp-imports #'mcg-lsp-organize-imports)
(defalias 'lsp-restart #'mcg-lsp-restart)
(defalias 'lsp-status #'mcg-lsp-status)
(defalias 'lsp-project #'mcg/lsp-project-info)
(defalias 'lsp-help #'mcg/lsp-help)

#+END_SRC

** ACM Keybindings Fix
#+BEGIN_SRC emacs-lisp
;;; ACM Keybindings Fix

(with-eval-after-load 'acm
  (define-key acm-mode-map (kbd "RET") #'acm-complete)
  (define-key acm-mode-map (kbd "<return>") #'acm-complete)
  (define-key acm-mode-map (kbd "C-m") #'acm-complete)
  (define-key acm-mode-map (kbd "TAB") #'acm-complete)
  (define-key acm-mode-map (kbd "<tab>") #'acm-complete))

#+END_SRC

** Initialize
#+BEGIN_SRC emacs-lisp
;;; Initialize

;; 设置 LSP (只执行一次)
(defvar mcg-lsp-setup-done nil
  "Flag to prevent duplicate LSP setup.")

(unless mcg-lsp-setup-done
  (mcg-lsp-setup)
  (setq mcg-lsp-setup-done t))

#+END_SRC

** Provide
#+BEGIN_SRC emacs-lisp
(provide 'init-lsp)
;;; init-lsp.el ends here
#+END_SRC
