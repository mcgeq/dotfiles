* init-lsp.el
:PROPERTIES:
:HEADER-ARGS: :tangle init-lsp.el :lexical t
:END:

** Headers
#+BEGIN_SRC emacs-lisp
  ;;; init-lsp.el --- Unified LSP Configuration for MCG Emacs -*- lexical-binding: t; -*-

  ;; Filename: init-lsp.el
  ;; Description: 统一的 LSP 配置模块
  ;; Author: mcge <mcgeq@outlook.com>
  ;; Copyright (C) 2024-2026, mcge, all rights reserved.
  ;; Create   Date: 2026-01-07
  ;; Version: 3.0
  ;; Keywords: lsp, language-server, development
  ;; Compatibility: GNU Emacs 29.0+

  ;;; Commentary:
  ;;
  ;; MCG Emacs 配置架构的统一 LSP 模块，负责：
  ;; - LSP Bridge 配置
  ;; - 统一快捷键绑定
  ;; - LSP 服务器映射
  ;; - 保存时自动格式化
  ;; - LSP 状态查询
  ;;
  ;; 模块元数据:
  ;; :depends ()
  ;; :defer nil
  ;;

#+END_SRC

** Dependencies
#+BEGIN_SRC emacs-lisp
;;; Dependencies

(require 'core-lib)

#+END_SRC

** LSP Server Mapping
#+BEGIN_SRC emacs-lisp
;;; LSP 服务器映射

(defvar mcg-lsp-servers
  '((rust-mode . "rust-analyzer")
    (rust-ts-mode . "rust-analyzer")
    (python-mode . "python-ty-ruff")
    (python-ts-mode . "python-ty-ruff")
    (typescript-mode . "typescript-biome")
    (typescript-ts-mode . "typescript-biome")
    (tsx-ts-mode . "typescript-biome")
    (js-mode . "typescript-biome")
    (js-ts-mode . "typescript-biome")
    (web-mode . "vue-full")
    (zig-mode . "zls")
    (zig-ts-mode . "zls")
    (c-mode . "clangd")
    (c-ts-mode . "clangd")
    (c++-mode . "clangd")
    (c++-ts-mode . "clangd")
    (lua-mode . "lua-language-server")
    (lua-ts-mode . "lua-language-server")
    (clojure-mode . "clojure-lsp")
    (clojure-ts-mode . "clojure-lsp"))
  "语言模式到 LSP 服务器的映射。

每个条目格式为 (MODE . SERVER-NAME)。
SERVER-NAME 对应 lsp-bridge 的服务器配置。")

#+END_SRC

** Unified Keybindings
#+BEGIN_SRC emacs-lisp
;;; 统一快捷键

(defvar mcg-lsp-keymap
  '(;; Navigation - 导航
    ("M-." . lsp-bridge-find-def)
    ("M-," . lsp-bridge-find-def-return)
    ("M-?" . lsp-bridge-find-references)
    
    ;; Documentation - 文档
    ("C-h ." . lsp-bridge-lookup-documentation)
    ("C-h ," . lsp-bridge-show-signature)
    
    ;; Refactoring - 重构
    ("C-c r r" . lsp-bridge-rename)
    ("C-c r a" . lsp-bridge-code-action)
    ("C-c r f" . lsp-bridge-code-format)
    ("C-c r i" . mcg-lsp-organize-imports)
    
    ;; Diagnostics - 诊断 (M-g prefix - standard Emacs "goto" prefix)
    ("M-g n" . lsp-bridge-diagnostic-jump-next)
    ("M-g p" . lsp-bridge-diagnostic-jump-prev)
    ("M-g l" . lsp-bridge-diagnostic-list)
    
    ;; Workspace - 工作区
    ("C-c r s" . lsp-bridge-workspace-list-symbols))
  "统一的 LSP 快捷键映射。

所有启用 LSP 的语言模式都使用相同的快捷键：
- M-. 跳转到定义
- M-, 返回
- M-? 查找引用
- C-c r r 重命名
- C-c r f 格式化")

(defun mcg-lsp-setup-keybindings ()
  "设置统一的 LSP 快捷键。

此函数在 lsp-bridge-mode-hook 中调用，
为当前 buffer 设置 mcg-lsp-keymap 中定义的快捷键。"
  (dolist (binding mcg-lsp-keymap)
    (local-set-key (kbd (car binding)) (cdr binding))))

#+END_SRC

** LSP Bridge Configuration
#+BEGIN_SRC emacs-lisp
;;; LSP Bridge 配置

(defvar mcg-lsp-user-langserver-dir nil
  "用户自定义 LSP 服务器配置目录。")

(defvar mcg-lsp-user-multiserver-dir nil
  "用户自定义多服务器配置目录。")

;; 设置默认的自定义服务器目录
(setq mcg-lsp-user-langserver-dir (expand-file-name "langservers" mcg-emacs-dir))
(setq mcg-lsp-user-multiserver-dir (expand-file-name "multiservers" mcg-emacs-dir))

(defun mcg-lsp-setup ()
  "设置 LSP Bridge 通用配置。

此函数配置 lsp-bridge 的核心选项，包括：
- 性能优化
- 补全设置
- 诊断设置
- 签名帮助"
  ;; 加载 lsp-bridge 扩展
  (unless (mcg-require-extension "lsp/lsp-bridge" 'lsp-bridge)
    (mcg-log "Warning: lsp-bridge extension not found")
    (cl-return-from mcg-lsp-setup nil))
  
  ;; 设置自定义服务器目录
  (when mcg-lsp-user-langserver-dir
    (setq lsp-bridge-user-langserver-dir mcg-lsp-user-langserver-dir))
  (when mcg-lsp-user-multiserver-dir
    (setq lsp-bridge-user-multiserver-dir mcg-lsp-user-multiserver-dir))
  
  ;; ===== 核心功能 =====
  (setq lsp-bridge-enable-completion-in-minibuffer t)
  (setq lsp-bridge-signature-show-function 'lsp-bridge-signature-show-with-frame)
  (setq lsp-bridge-signature-show-with-frame-position "bottom-right")
  (setq lsp-bridge-enable-with-tramp t)
  (setq lsp-bridge-enable-org-babel t)
  
  ;; ===== 性能优化 =====
  (setq lsp-bridge-enable-inlay-hint nil)  ; 禁用以提升性能
  (setq lsp-bridge-semantic-tokens nil)    ; 禁用语义 token
  (setq lsp-bridge-diagnostic-fetch-idle 0.5)
  (setq lsp-bridge-signature-help-fetch-idle 0.8)
  
  ;; ===== 诊断设置 =====
  (setq lsp-bridge-enable-diagnostics t)
  (setq lsp-bridge-enable-hover-diagnostic t)
  (setq lsp-bridge-code-action-enable-popup-tip t)
  
  ;; ===== 补全设置 =====
  (setq lsp-bridge-enable-search-words t)
  (setq lsp-bridge-enable-auto-import t)
  (setq lsp-bridge-enable-auto-format-code nil)  ; 手动控制格式化
  (setq lsp-bridge-find-def-select-in-open-windows t)
  (setq lsp-bridge-enable-rename-file t)
  
  ;; ===== ACM 配置 =====
  (setq acm-enable-capf t)
  (setq acm-enable-quick-access t)
  (setq acm-backend-yas-match-by-trigger-keyword t)
  (setq acm-enable-tabnine nil)
  (setq acm-enable-codeium nil)
  (setq acm-candidate-match-function 'regexp-quote)
  (setq acm-enable-lsp-workspace-symbol nil)
  (setq acm-enable-doc nil)
  (setq acm-doc-frame-pos 'bottom-right)
  (setq acm-enable-icon t)
  (setq acm-enable-doc-markdown-render 'async)
  (setq acm-candidate-match-max-length 50)
  (setq acm-enable-preview nil)
  (setq acm-menu-length 8)
  (setq acm-enable-path t)
  (setq acm-enable-search-file-words nil)
  (setq acm-frame-max-width 100)
  
  ;; ===== 补全触发配置 =====
  (setq acm-backend-lsp-candidate-min-length 1)
  (setq acm-backend-elisp-candidate-min-length 1)
  (setq acm-backend-yas-candidate-min-length 1)
  (setq acm-backend-search-file-words-candidate-min-length 2)
  
  ;; ===== 多服务器配置 =====
  (with-eval-after-load 'lsp-bridge
    ;; TypeScript/JavaScript with Biome
    (add-to-list 'lsp-bridge-multi-lang-server-extension-list '(("ts") . "typescript-biome"))
    (add-to-list 'lsp-bridge-multi-lang-server-extension-list '(("tsx") . "typescript-biome"))
    (add-to-list 'lsp-bridge-multi-lang-server-extension-list '(("js") . "typescript-biome"))
    (add-to-list 'lsp-bridge-multi-lang-server-extension-list '(("jsx") . "typescript-biome"))
    
    ;; Vue with full stack
    (add-to-list 'lsp-bridge-multi-lang-server-extension-list '(("vue") . "vue-full"))
    
    ;; Python with ty + ruff
    (add-to-list 'lsp-bridge-multi-lang-server-extension-list '(("py") . "python-ty-ruff"))
    (add-to-list 'lsp-bridge-multi-lang-server-extension-list '(("pyi") . "python-ty-ruff")))
  
  ;; 设置快捷键 hook
  (add-hook 'lsp-bridge-mode-hook #'mcg-lsp-setup-keybindings)
  
  ;; 启用全局 lsp-bridge-mode
  (global-lsp-bridge-mode)
  
  (mcg-log "LSP setup complete"))

#+END_SRC

** Format on Save
#+BEGIN_SRC emacs-lisp
;;; 保存时自动格式化

(defvar mcg-lsp-format-on-save-modes
  '(python-mode
    python-ts-mode
    rust-mode
    rust-ts-mode
    zig-mode
    zig-ts-mode
    c-mode
    c-ts-mode
    c++-mode
    c++-ts-mode
    typescript-mode
    typescript-ts-mode
    tsx-ts-mode
    js-mode
    js-ts-mode)
  "启用保存时格式化的模式列表。")

(defvar mcg-lsp-organize-imports-modes
  '(python-mode
    python-ts-mode
    typescript-mode
    typescript-ts-mode
    tsx-ts-mode
    js-mode
    js-ts-mode)
  "启用保存时整理 imports 的模式列表。")

(defvar mcg-lsp-format-on-save-enabled t
  "是否启用保存时自动格式化。")

(defun mcg-lsp-format-on-save ()
  "保存时格式化 buffer。

如果 `mcg-lsp-format-on-save-enabled' 为 t，
且当前模式在 `mcg-lsp-format-on-save-modes' 中，
则调用 lsp-bridge-code-format。"
  (when (and mcg-lsp-format-on-save-enabled
             (bound-and-true-p lsp-bridge-mode)
             (member major-mode mcg-lsp-format-on-save-modes))
    (lsp-bridge-code-format)))

(defun mcg/toggle-format-on-save ()
  "切换保存时自动格式化。"
  (interactive)
  (setq mcg-lsp-format-on-save-enabled (not mcg-lsp-format-on-save-enabled))
  (message "Format on save: %s"
           (if mcg-lsp-format-on-save-enabled "enabled" "disabled")))

;; 启用保存时格式化
(add-hook 'before-save-hook #'mcg-lsp-format-on-save)

#+END_SRC

** Utility Functions
#+BEGIN_SRC emacs-lisp
;;; 工具函数

(defun mcg-lsp-format-buffer ()
  "格式化当前 buffer。"
  (interactive)
  (if (and (fboundp 'lsp-bridge-mode)
           (bound-and-true-p lsp-bridge-mode))
      (lsp-bridge-code-format)
    (message "LSP not active in current buffer")))

(defun mcg-lsp-organize-imports ()
  "整理当前 buffer 的 imports。

根据当前 major-mode 选择合适的工具：
- Python: 使用 ruff
- Rust: 使用 rustfmt
- 其他: 尝试 LSP code action"
  (interactive)
  (cond
   ;; Python: 使用 ruff
   ((member major-mode '(python-mode python-ts-mode))
    (if (executable-find "ruff")
        (let ((file (buffer-file-name)))
          (when file
            (save-buffer)
            (if (zerop (call-process "ruff" nil nil nil "check" "--select" "I" "--fix" file))
                (progn
                  (revert-buffer t t t)
                  (message "Sorted imports with ruff"))
              (message "ruff: no import changes needed"))))
      (message "ruff not found")))
   
   ;; Rust: 使用 rustfmt
   ((member major-mode '(rust-mode rust-ts-mode))
    (lsp-bridge-code-format)
    (message "Rust imports organized via rustfmt"))
   
   ;; 其他语言: 尝试 LSP code action
   ((bound-and-true-p lsp-bridge-mode)
    (lsp-bridge-code-action))
   
   (t
    (message "No import organizer available for this mode"))))

(defun mcg-lsp-restart ()
  "重启 LSP 服务器。"
  (interactive)
  (when (bound-and-true-p lsp-bridge-mode)
    (lsp-bridge-restart-process)
    (message "LSP server restarted")))

#+END_SRC

** LSP Status Command
#+BEGIN_SRC emacs-lisp
;;; LSP 状态命令

(defun mcg-lsp-check-server-available (server-name)
  "检查 LSP 服务器是否可用。

参数:
- SERVER-NAME: 服务器可执行文件名

返回 t 如果服务器在 PATH 中可用。"
  (executable-find server-name))

(defun mcg-lsp-status ()
  "显示所有 LSP 服务器的状态。

交互式命令，显示各语言 LSP 服务器的可用性。"
  (interactive)
  (let ((servers '(("Python (ty)" . "ty")
                   ("Python (ruff)" . "ruff")
                   ("TypeScript" . "typescript-language-server")
                   ("Biome" . "biome")
                   ("Rust" . "rust-analyzer")
                   ("Zig" . "zls")
                   ("C/C++ (clangd)" . "clangd")
                   ("Lua" . "lua-language-server")
                   ("Clojure" . "clojure-lsp"))))
    (with-help-window "*MCG LSP Status*"
      (princ "═══════════════════════════════════\n")
      (princ "   LSP Server Availability\n")
      (princ "═══════════════════════════════════\n\n")
      (dolist (server servers)
        (let ((name (car server))
              (executable (cdr server)))
          (princ (format "%-20s %s\n"
                         name
                         (if (mcg-lsp-check-server-available executable)
                             "✓ Available"
                           "✗ Not found")))))
      (princ "\n═══════════════════════════════════\n")
      (princ "\nInstallation instructions:\n")
      (princ "  Python (ty):   uv tool install ty\n")
      (princ "  Python (ruff): uv tool install ruff\n")
      (princ "  TypeScript:    npm install -g typescript-language-server\n")
      (princ "  Biome:         npm install -g @biomejs/biome\n")
      (princ "  Rust:          rustup component add rust-analyzer\n")
      (princ "  Zig:           Download from github.com/zigtools/zls\n")
      (princ "  C/C++:         Install clangd from LLVM\n")
      (princ "  Lua:           Install lua-language-server\n")
      (princ "  Clojure:       Install clojure-lsp\n"))))

#+END_SRC

** Project Detection
#+BEGIN_SRC emacs-lisp
;;; 项目检测

(defun mcg-lsp-detect-project-type ()
  "检测当前项目类型。

根据项目根目录中的文件检测项目类型。
返回项目类型符号，如 'python, 'rust, 'javascript 等。"
  (when-let* ((project-root (when (project-current)
                              (project-root (project-current)))))
    (cond
     ;; Python
     ((or (file-exists-p (expand-file-name "setup.py" project-root))
          (file-exists-p (expand-file-name "pyproject.toml" project-root))
          (file-exists-p (expand-file-name "requirements.txt" project-root)))
      'python)
     
     ;; JavaScript/TypeScript
     ((or (file-exists-p (expand-file-name "package.json" project-root))
          (file-exists-p (expand-file-name "tsconfig.json" project-root)))
      'javascript)
     
     ;; Rust
     ((file-exists-p (expand-file-name "Cargo.toml" project-root))
      'rust)
     
     ;; Zig
     ((file-exists-p (expand-file-name "build.zig" project-root))
      'zig)
     
     ;; C/C++
     ((or (file-exists-p (expand-file-name "CMakeLists.txt" project-root))
          (file-exists-p (expand-file-name "Makefile" project-root))
          (file-exists-p (expand-file-name "compile_commands.json" project-root)))
      'c-cpp)
     
     ;; Clojure
     ((or (file-exists-p (expand-file-name "deps.edn" project-root))
          (file-exists-p (expand-file-name "project.clj" project-root)))
      'clojure)
     
     (t 'unknown))))

(defun mcg/lsp-project-info ()
  "显示当前项目信息。"
  (interactive)
  (let ((project-type (mcg-lsp-detect-project-type))
        (project-root (when (project-current)
                        (project-root (project-current)))))
    (message "Project: %s | Type: %s"
             (or project-root "None")
             (or project-type "unknown"))))

#+END_SRC

** Help Command
#+BEGIN_SRC emacs-lisp
;;; 帮助命令

(defun mcg/lsp-help ()
  "显示 LSP 快捷键和命令帮助。"
  (interactive)
  (with-help-window "*MCG LSP Help*"
    (princ "
╔═══════════════════════════════════════════╗
║       MCG LSP Keybindings                 ║
╚═══════════════════════════════════════════╝

NAVIGATION:
  M-.        - Go to definition
  M-,        - Return from definition
  M-?        - Find references

DOCUMENTATION:
  C-h .      - Show documentation
  C-h ,      - Show signature

REFACTORING:
  C-c r r    - Rename symbol
  C-c r a    - Code action
  C-c r f    - Format buffer
  C-c r i    - Organize imports

DIAGNOSTICS:
  M-g n      - Next diagnostic
  M-g p      - Previous diagnostic
  M-g l      - List all diagnostics

WORKSPACE:
  C-c r s    - List workspace symbols

═══════════════════════════════════════════

QUICK COMMANDS:
  M-x mcg-lsp-format-buffer   - Format buffer
  M-x mcg-lsp-organize-imports - Organize imports
  M-x mcg-lsp-restart         - Restart LSP server
  M-x mcg-lsp-status          - Check server availability
  M-x mcg/lsp-project-info    - Show project info

═══════════════════════════════════════════

SETTINGS:
  M-x mcg/toggle-format-on-save
    Toggle automatic formatting on save

Current status:
  Format on save: ")
    (princ (if mcg-lsp-format-on-save-enabled "✓ Enabled" "✗ Disabled"))
    (princ "\n\n═══════════════════════════════════════════\n")))

#+END_SRC

** Quick Aliases
#+BEGIN_SRC emacs-lisp
;;; 快捷别名

(defalias 'lsp-format #'mcg-lsp-format-buffer)
(defalias 'lsp-imports #'mcg-lsp-organize-imports)
(defalias 'lsp-restart #'mcg-lsp-restart)
(defalias 'lsp-status #'mcg-lsp-status)
(defalias 'lsp-project #'mcg/lsp-project-info)
(defalias 'lsp-help #'mcg/lsp-help)

#+END_SRC

** ACM Keybindings Fix
#+BEGIN_SRC emacs-lisp
;;; ACM 快捷键修复

(with-eval-after-load 'acm
  (define-key acm-mode-map (kbd "RET") #'acm-complete)
  (define-key acm-mode-map (kbd "<return>") #'acm-complete)
  (define-key acm-mode-map (kbd "C-m") #'acm-complete)
  (define-key acm-mode-map (kbd "TAB") #'acm-complete)
  (define-key acm-mode-map (kbd "<tab>") #'acm-complete))

#+END_SRC

** Initialize
#+BEGIN_SRC emacs-lisp
;;; Initialize

;; 设置 LSP
(mcg-lsp-setup)

#+END_SRC

** Provide
#+BEGIN_SRC emacs-lisp
(provide 'init-lsp)
;;; init-lsp.el ends here
#+END_SRC
